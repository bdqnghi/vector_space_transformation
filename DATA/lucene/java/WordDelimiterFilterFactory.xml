org.apache.lucene.analysis.miscellaneous org.apache.lucene.analysis.TokenFilter import org.apache.lucene.analysis.TokenStream import org.apache.lucene.analysis.util.CharArraySet import org.apache.lucene.analysis.util.ResourceLoader import org.apache.lucene.analysis.util.ResourceLoaderAware import org.apache.lucene.analysis.util.TokenFilterFactory import org.apache.lucene.util.Version import java.util.ArrayList import java.util.List import java.util.Map import java.util.SortedMap import java.util.TreeMap import java.util.regex.Matcher import java.util.regex.Pattern import java.io.IOException import static static org.apache.lucene.analysis.miscellaneous.WordDelimiterFilter.* import class org.apache.lucene.analysis.miscellaneous.WordDelimiterFilterFactory super super extends super implements CharArraySet String Pattern String int String decl byte String decl char decl List decl List decl List public public throws if != = if != decl_stmt java.util.List < = decl_stmt java.util.List < = new <> for : decl_stmt java.util.List < = call decl List.addAll() call decl List.addAll() call decl List.addAll() call decl List.addAll() call decl List.addAll() = public public return new == : String Byte byte Matcher decl SortedMap private private < decl_stmt java.util.SortedMap < = new <> for : decl_stmt java.util.regex.Matcher = call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) if ! call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) throw new + + decl_stmt java.lang.String = call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) decl_stmt java.lang.Byte = call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) if call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() != throw new + + if == throw new + + call decl SortedMap.put() call decl SortedMap.put() call decl SortedMap.put() call decl SortedMap.put() call decl SortedMap.put() call java.lang.String.charAt(int) call java.lang.String.charAt(int) call java.lang.String.charAt(int) call java.lang.String.charAt(int) call java.lang.String.charAt(int) decl_stmt byte = new call decl SortedMap.lastKey() call decl SortedMap.lastKey() call decl SortedMap.lastKey() call decl SortedMap.lastKey() call decl SortedMap.lastKey() + for = < ++ = for < : call decl SortedMap.entrySet() call decl SortedMap.entrySet() call decl SortedMap.entrySet() call decl SortedMap.entrySet() call decl SortedMap.entrySet() = return private private if return else if return else if return else if return else if return else if return else return char int int int private private decl_stmt int = decl_stmt int = decl_stmt int = while < decl_stmt char = ++ if == if >= throw new + + = ++ switch case = break case = break case = break case = break case = break case = break case if + >= throw new + + = char + += break ++ = return new