org.apache.lucene.store java.io.FileNotFoundException import java.io.FilterOutputStream import java.io.IOException import java.nio.channels.ClosedChannelException import java.nio.file.DirectoryStream import java.nio.file.FileAlreadyExistsException import java.nio.file.Files import java.nio.file.NoSuchFileException import java.nio.file.OpenOption import java.nio.file.Path import java.nio.file.StandardCopyOption import java.nio.file.StandardOpenOption import java.util.ArrayList import java.util.Arrays import java.util.Collection import java.util.Collections import java.util.HashSet import java.util.List import java.util.Set import java.util.concurrent.ConcurrentHashMap import java.util.concurrent.Future import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.atomic.AtomicLong import org.apache.lucene.index.IndexFileNames import org.apache.lucene.util.Constants import org.apache.lucene.util.IOUtils import class org.apache.lucene.store.FSDirectory super super extends Path AtomicLong decl Set AtomicInteger public static public static throws return public static public static throws if && return new else if return new else return new public static public static throws return decl String String decl List private static private static < throws decl_stmt java.util.List < = new <> try < = for : decl_stmt java.lang.String = if != && == call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() decl_stmt java.lang.String = call decl List.toArray() call decl List.toArray() call decl List.toArray() call decl List.toArray() call decl List.toArray() new call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() return public public throws return public public throws if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() throw new + + return call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) public public throws call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() return new String public public throws while try decl_stmt java.lang.String = + + call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() continue return new catch protected protected throws if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() throw new + + public public < throws for : public public throws if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() throw new + + call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) public synchronized public synchronized throws = public public return public public return + + + + protected protected throws call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) public public throws if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() throw new + + public public throws return call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() == public synchronized public synchronized throws if call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() == for : new <> int private private throws if call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() == decl_stmt int = call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() if >= call decl Set.size() call decl Set.size() call decl Set.size() call decl Set.size() call decl Set.size() call java.util.concurrent.atomic.AtomicInteger.addAndGet(int) call java.util.concurrent.atomic.AtomicInteger.addAndGet(int) call java.util.concurrent.atomic.AtomicInteger.addAndGet(int) call java.util.concurrent.atomic.AtomicInteger.addAndGet(int) call java.util.concurrent.atomic.AtomicInteger.addAndGet(int) - private private throws try call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call java.nio.file.Path.resolve(Path) call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() catch call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() if && else throw catch call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() int public public throws while > decl_stmt int final final = -= +=