org.apache.solr.cloud.rule java.lang.invoke.MethodHandles import java.util.ArrayList import java.util.BitSet import java.util.Collections import java.util.Comparator import java.util.HashMap import java.util.HashSet import java.util.Iterator import java.util.LinkedHashMap import java.util.List import java.util.Map import java.util.Set import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.atomic.AtomicReference import org.apache.solr.common.SolrException import org.apache.solr.common.cloud.ClusterState import org.apache.solr.common.cloud.DocCollection import org.apache.solr.common.cloud.Replica import org.apache.solr.common.cloud.Slice import org.apache.solr.common.util.StrUtils import org.apache.solr.common.util.Utils import org.apache.solr.core.CoreContainer import org.slf4j.Logger import org.slf4j.LoggerFactory import static static java.util.Collections.singletonList import static static org.apache.solr.cloud.rule.Rule.MatchStatus.* import static static org.apache.solr.cloud.rule.Rule.Phase.* import static static org.apache.solr.common.util.StrUtils.formatString import static static org.apache.solr.common.util.Utils.getDeepCopy import class org.apache.solr.cloud.rule.ReplicaAssigner decl List decl Map Logger decl List decl Map decl Set decl Map decl Map decl Map public public return > - : == : public public return + + public < < public < < return String decl Map decl Map public < public < decl_stmt java.util.Map < = if == decl_stmt java.lang.String = + if ! call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() decl_stmt java.util.Map < = new <> for < : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() += + += + if ! call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() += + throw new return decl Map decl List boolean decl int int < < decl_stmt java.util.List < = new <> call decl Map.keySet() call decl Map.keySet() call decl Map.keySet() call decl Map.keySet() call decl Map.keySet() decl_stmt int = new call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() for = < call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() ++ = decl_stmt boolean = decl_stmt int = for : if = if ! ++ if call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() > throw new decl_stmt java.util.Map < = if == && = return decl int decl int decl Map decl Iterator decl List private < private < < decl_stmt java.util.Iterator < = > : for call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() decl_stmt int = call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() decl_stmt java.util.List < = new <> for : for = < call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() ++ call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() new for < = call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() decl_stmt int = decl_stmt java.util.Map < = if != return return int decl Rule String int int int AtomicInteger Integer Number int decl Map decl Map decl Map Rule AtomicInteger decl Map decl List decl MatchStatus private < private < < decl_stmt java.util.Map < < = decl_stmt java.util.Map < = new <> decl_stmt int = decl_stmt java.util.Map < < = decl_stmt java.util.List < = new <> decl_stmt int = for = < ++ decl_stmt org.apache.solr.cloud.rule.Rule = call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() decl_stmt int = call Number.compare() call Number.compare() call Number.compare() call Number.compare() call Number.compare() if != = break if == decl_stmt java.util.concurrent.atomic.AtomicInteger = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() decl_stmt java.util.concurrent.atomic.AtomicInteger = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() decl_stmt int = == : call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() decl_stmt int = == : call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() = > : == : - return for : for = < call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() ++ decl_stmt java.lang.String = call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() ++ for = < ++ decl_stmt org.apache.solr.cloud.rule.Rule = call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() decl_stmt MatchStatus = call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() : if == continue continue call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() decl_stmt java.util.Map < = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if == call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() = new <> decl_stmt java.lang.Integer = call decl MatchStatus.get() call decl MatchStatus.get() call decl MatchStatus.get() call decl MatchStatus.get() call decl MatchStatus.get() = == : + call decl MatchStatus.put() call decl MatchStatus.put() call decl MatchStatus.put() call decl MatchStatus.put() call decl MatchStatus.put() decl_stmt java.lang.Number = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if != call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() + continue continue return if > call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() return for < : call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() for = < ++ decl_stmt org.apache.solr.cloud.rule.Rule = call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() decl_stmt MatchStatus = call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() call Number.tryAssignNodeToShard() : if != && != return return decl List private private < < decl_stmt java.util.List < = new <> for : for < < : call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() if == call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() if ! call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() throw new int decl AtomicReference decl int public static < public static < final final return new < decl_stmt int = decl_stmt int public public decl_stmt java.util.concurrent.atomic.AtomicReference < = new <> new new new ++ = call decl AtomicReference.get() call decl AtomicReference.get() call decl AtomicReference.get() call decl AtomicReference.get() call decl AtomicReference.get() return != public public return decl AtomicReference public public decl_stmt java.util.concurrent.atomic.AtomicReference < = new <> new new new ++ = call decl AtomicReference.get() call decl AtomicReference.get() call decl AtomicReference.get() call decl AtomicReference.get() call decl AtomicReference.get() return != public public return private static private static < if == if == else else for = < ++ if ! = + if != break public < public < return public public return String boolean decl Map decl Map SnitchContext decl Map private < < private < < final final decl_stmt java.util.Map < = for : if call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() continue try call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() new catch throw new + for : decl_stmt boolean = for : call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() if = break if ! throw new + for : for : call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() if ! decl_stmt org.apache.solr.cloud.rule.SnitchContext = new try catch = decl_stmt java.util.Map < < = new <> for : call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() for < : decl_stmt org.apache.solr.cloud.rule.SnitchContext = decl_stmt java.lang.String = if != call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl List.remove() call decl List.remove() call decl List.remove() call decl List.remove() call decl List.remove() call Logger.warn() call Logger.warn() call Logger.warn() call Logger.warn() call Logger.warn() + = new + else if call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() call SnitchContext.snitchInfo() decl_stmt java.util.Map < = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if == = new <> call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.putAll() call decl Map.putAll() call decl Map.putAll() call decl Map.putAll() call decl Map.putAll() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() call org.apache.solr.cloud.rule.SnitchContext.getTags() if call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() throw new return public static public static decl Map Snitch String Map static < static < if == = decl_stmt java.util.Map < = new <> for : decl_stmt java.lang.String = decl_stmt java.util.Map = if instanceof = = call java.util.Map.get(Object) call java.util.Map.get(Object) call java.util.Map.get(Object) call java.util.Map.get(Object) call java.util.Map.get(Object) if == throw new else = try if call java.lang.String.indexOf(String,int) call java.lang.String.indexOf(String,int) call java.lang.String.indexOf(String,int) call java.lang.String.indexOf(String,int) call java.lang.String.indexOf(String,int) == - = + + decl_stmt Snitch = == : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call Snitch.getClass() call Snitch.getClass() call Snitch.getClass() call Snitch.getClass() call Snitch.getClass() new catch throw new return