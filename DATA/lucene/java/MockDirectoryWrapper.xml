org.apache.lucene.store java.io.Closeable import java.io.FileNotFoundException import java.io.IOException import java.nio.file.NoSuchFileException import java.util.ArrayList import java.util.Arrays import java.util.Collection import java.util.Collections import java.util.HashMap import java.util.HashSet import java.util.IdentityHashMap import java.util.Iterator import java.util.List import java.util.Locale import java.util.Map import java.util.Random import java.util.Set import java.util.TreeSet import java.util.concurrent.ConcurrentHashMap import java.util.concurrent.ConcurrentMap import java.util.concurrent.atomic.AtomicInteger import java.util.regex.Matcher import org.apache.lucene.index.DirectoryReader import org.apache.lucene.index.IndexFileNames import org.apache.lucene.index.IndexWriter import org.apache.lucene.index.IndexWriterConfig import org.apache.lucene.index.NoDeletionPolicy import org.apache.lucene.index.SegmentInfos import org.apache.lucene.util.CollectionUtil import org.apache.lucene.util.IOUtils import org.apache.lucene.util.LuceneTestCase import org.apache.lucene.util.TestUtil import org.apache.lucene.util.ThrottledIndexOutput import class org.apache.lucene.store.MockDirectoryWrapper super super extends Throttling double long long Random boolean boolean boolean ThrottledIndexOutput boolean decl Map boolean decl Set boolean double decl Set boolean decl Set boolean decl Map decl ConcurrentMap boolean decl Set boolean decl ArrayList boolean AtomicInteger private synchronized private synchronized if == = new <> = new <> if == = new <> if == = new <> public public return call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() public public = public public = public public = public public = public public = public public = public public = public synchronized public synchronized < throws if throw new for : call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() boolean public synchronized public synchronized throws if throw new if call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() && throw new + + if call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() && throw new + + decl_stmt boolean = try = finally if if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() long public synchronized final public synchronized final throws if instanceof return else decl_stmt long = for : if ! += return decl Set SegmentInfos decl Set Matcher public synchronized public synchronized throws decl_stmt java.util.Set < = new <> for : if + + decl_stmt org.apache.lucene.index.SegmentInfos try = catch + + + throw call decl Set.addAll() call decl Set.addAll() call decl Set.addAll() call decl Set.addAll() call decl Set.addAll() call org.apache.lucene.index.SegmentInfos.files(boolean) call org.apache.lucene.index.SegmentInfos.files(boolean) call org.apache.lucene.index.SegmentInfos.files(boolean) call org.apache.lucene.index.SegmentInfos.files(boolean) call org.apache.lucene.index.SegmentInfos.files(boolean) decl_stmt java.util.Set < = new <> decl_stmt java.util.regex.Matcher = for : call java.util.regex.Matcher.reset(CharSequence) call java.util.regex.Matcher.reset(CharSequence) call java.util.regex.Matcher.reset(CharSequence) call java.util.regex.Matcher.reset(CharSequence) call java.util.regex.Matcher.reset(CharSequence) if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() == && == && call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() || call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() decl byte long byte int int String long int String long long decl List public synchronized public synchronized < throws decl_stmt java.util.List final final final < = new <> for : decl_stmt int = call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) decl_stmt java.lang.String = switch case = break case = decl_stmt long try = catch continue decl_stmt byte = new decl_stmt long = try = while < decl_stmt int final final = int - += catch break case = decl_stmt java.lang.String = try = = = / catch try = = catch break case = break case decl_stmt java.lang.String = try = = = if > decl_stmt long = call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() * if > decl_stmt byte = decl_stmt int = call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) = ^ << = + + + + + + decl_stmt long = - - if > else = catch try = = catch break case = try = catch break default: throw new if + + + decl Map public synchronized public synchronized throws = new <> = new <> = new <> decl_stmt java.util.Map < = new <> for : call decl Map.keySet() call decl Map.keySet() call decl Map.keySet() call decl Map.keySet() call decl Map.keySet() try catch = = new <> public synchronized public synchronized = call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() public public = public public return public public return public public throws = public public = public public return public public = public public return public public = public public return IOException throws if call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() < decl_stmt IOException = new + == : + + if + + == : + + call IOException.printStackTrace() call IOException.printStackTrace() call IOException.printStackTrace() call IOException.printStackTrace() call IOException.printStackTrace() throw throws if call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() < if + + new if == || call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() throw new + + else throw call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() new + + : new + + public synchronized public synchronized return call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() public synchronized public synchronized throws if throw new if call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() if throw new + + else call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() private synchronized private synchronized for < : call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() if && instanceof && break else if ! && instanceof && break return private private if call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() public synchronized < public synchronized < return new <> public public = IndexOutput RAMDirectory IndexOutput RAMFile RAMFile public synchronized public synchronized throws if if throw new synchronized if && call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() && ! throw new + + if && call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() call decl Map.containsKey() throw new + + call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() if instanceof decl_stmt org.apache.lucene.store.RAMDirectory = decl_stmt org.apache.lucene.store.RAMFile = new decl_stmt org.apache.lucene.store.RAMFile = call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() if != && ! && throw new + + else if != call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() call RAMDirectory.sizeInBytes() - = call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() call RAMDirectory.fileMap() decl_stmt org.apache.lucene.store.IndexOutput = decl_stmt org.apache.lucene.store.IndexOutput final final = new call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() if == || == && call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) == if + + return call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) else return IndexOutput String IndexOutput public synchronized public synchronized throws + + + if if throw new decl_stmt org.apache.lucene.store.IndexOutput = decl_stmt java.lang.String = call org.apache.lucene.store.IndexOutput.getName() call org.apache.lucene.store.IndexOutput.getName() call org.apache.lucene.store.IndexOutput.getName() call org.apache.lucene.store.IndexOutput.getName() call org.apache.lucene.store.IndexOutput.getName() if call java.lang.String.toLowerCase(Locale) call java.lang.String.toLowerCase(Locale) call java.lang.String.toLowerCase(Locale) call java.lang.String.toLowerCase(Locale) call java.lang.String.toLowerCase(Locale) == throw new + call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() decl_stmt org.apache.lucene.store.IndexOutput final final = new call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() if == || == && call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) == if + + return call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) call org.apache.lucene.util.ThrottledIndexOutput.newFromDelegate(IndexOutput) else return Integer synchronized synchronized decl_stmt java.lang.Integer = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if != = call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() + call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() else call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() new + + + public public = IndexInput int IndexInput public synchronized public synchronized throws if if ! throw call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() call java.util.Random.nextBoolean() new + + : new + + if ! && call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() && ! throw new + + decl_stmt org.apache.lucene.store.IndexInput = decl_stmt org.apache.lucene.store.IndexInput final final decl_stmt int = call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) call java.util.Random.nextInt(int) if && == if + = new else if && == if + = new else = new return long public synchronized final public synchronized final throws if ! instanceof return decl_stmt long = for final final : += return long public final synchronized public final synchronized throws if ! instanceof return decl_stmt long = for final final : += return public public = decl Set IndexWriterConfig boolean decl Set decl String DirectoryReader DirectoryReader int int decl String decl Set decl Iterator decl List Exception decl List String public synchronized public synchronized throws if = else return decl_stmt boolean = try if == = new <> = new <> if call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() > decl_stmt Exception = decl_stmt java.util.Iterator < = call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() call decl Map.values() if call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() = call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() throw new + if call decl ConcurrentMap.size() call decl ConcurrentMap.size() call decl ConcurrentMap.size() call decl ConcurrentMap.size() call decl ConcurrentMap.size() > decl_stmt Exception = decl_stmt java.util.Iterator < = call decl ConcurrentMap.values() call decl ConcurrentMap.values() call decl ConcurrentMap.values() call decl ConcurrentMap.values() call decl ConcurrentMap.values() if call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() = call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() throw new + = = if || && if if if if decl_stmt java.util.Set < = new <> decl_stmt java.lang.String = call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() new decl_stmt org.apache.lucene.index.IndexWriterConfig = new call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) new decl_stmt java.lang.String = decl_stmt java.util.Set < = new <> decl_stmt java.util.Set < = new <> = call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() new = call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() call decl Set.toArray() new if ! decl_stmt java.util.List < = new <> for : if ! call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() decl_stmt java.util.List < = new <> for : if ! call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() decl_stmt java.lang.String if call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() != = + else = if call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() != += + throw new + + + + decl_stmt org.apache.lucene.index.DirectoryReader = decl_stmt int = call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() new new decl_stmt org.apache.lucene.index.DirectoryReader = decl_stmt int = call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() assert == : + + + = finally if else Integer synchronized synchronized decl_stmt java.lang.Integer = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if != if call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() == call decl Map.remove() call decl Map.remove() call decl Map.remove() call decl Map.remove() call decl Map.remove() else = call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() call java.lang.Integer.intValue() - call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.remove() call decl Map.remove() call decl Map.remove() call decl Map.remove() call decl Map.remove() public synchronized public synchronized call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() public synchronized public synchronized public public throws public public return public public = public public = synchronized public synchronized public if == = new <> call decl ArrayList.add() call decl ArrayList.add() call decl ArrayList.add() call decl ArrayList.add() call decl ArrayList.add() synchronized synchronized throws if != for = < call decl ArrayList.size() call decl ArrayList.size() call decl ArrayList.size() call decl ArrayList.size() call decl ArrayList.size() ++ try call decl ArrayList.get() call decl ArrayList.get() call decl ArrayList.get() call decl ArrayList.get() call decl ArrayList.get() catch if public synchronized public synchronized throws return public synchronized public synchronized throws return public synchronized public synchronized throws return public public if != return + + + + + + else return public final public final throws return public final public final throws protected final protected final throws