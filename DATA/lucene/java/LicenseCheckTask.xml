org.apache.lucene.validation java.io.File import java.io.FileInputStream import java.io.BufferedReader import java.io.InputStreamReader import java.io.IOException import java.nio.charset.StandardCharsets import java.util.ArrayList import java.util.Iterator import java.util.LinkedHashMap import java.util.List import java.util.Locale import java.util.Map import java.util.regex.Matcher import java.util.regex.Pattern import java.util.regex.PatternSyntaxException import java.security.DigestInputStream import java.security.MessageDigest import java.security.NoSuchAlgorithmException import org.apache.tools.ant.BuildException import org.apache.tools.ant.Project import org.apache.tools.ant.Task import org.apache.tools.ant.types.Mapper import org.apache.tools.ant.types.Resource import org.apache.tools.ant.types.ResourceCollection import org.apache.tools.ant.types.resources.FileResource import org.apache.tools.ant.types.resources.Resources import org.apache.tools.ant.util.FileNameMapper import class org.apache.lucene.validation.LicenseCheckTask super super extends boolean int File Resources String int boolean Pattern boolean int String FileNameMapper public public call Resources.add() call Resources.add() call Resources.add() call Resources.add() call Resources.add() public public if != throw new = public public = : public public = public public = public public = public public try if != && call Pattern.length() call Pattern.length() call Pattern.length() call Pattern.length() call Pattern.length() > = catch throw new + + + public public throws if == throw new if else if if != + call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call Resources.setProject() call Resources.setProject() call Resources.setProject() call Resources.setProject() call Resources.setProject() if throw new int int decl Iterator long Resource File private private decl_stmt long = decl_stmt java.util.Iterator < = < call Resources.iterator() call Resources.iterator() call Resources.iterator() call Resources.iterator() call Resources.iterator() decl_stmt int = decl_stmt int = while call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() decl_stmt sun.misc.Resource final final = call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() if ! call Resource.isExists() call Resource.isExists() call Resource.isExists() call Resource.isExists() call Resource.isExists() throw new + call Resource.getName() call Resource.getName() call Resource.getName() call Resource.getName() call Resource.getName() if ! instanceof throw new + call Resource.getName() call Resource.getName() call Resource.getName() call Resource.getName() call Resource.getName() + + call Resource.getClass() call Resource.getClass() call Resource.getClass() call Resource.getClass() call Resource.getClass() decl_stmt File = if ! ++ ++ - / > : String decl List LicenseType MessageDigest String String String decl Map File File FileInputStream boolean StringBuilder decl byte decl byte DigestInputStream private private + if ! decl_stmt boolean = && if ! && ! decl_stmt File final final = new + + if ! call File.exists() call File.exists() call File.exists() call File.exists() call File.exists() && call File.canRead() call File.canRead() call File.canRead() call File.canRead() call File.canRead() + + + + + + call File.getPath() call File.getPath() call File.getPath() call File.getPath() call File.getPath() = return else decl_stmt java.lang.String final final = try decl_stmt java.security.MessageDigest final final = decl_stmt byte = new try decl_stmt FileInputStream = new try decl_stmt java.security.DigestInputStream = new try while call java.security.DigestInputStream.read() call java.security.DigestInputStream.read() call java.security.DigestInputStream.read() call java.security.DigestInputStream.read() call java.security.DigestInputStream.read() != - finally call DigestInputStream.close() call DigestInputStream.close() call DigestInputStream.close() call DigestInputStream.close() call DigestInputStream.close() finally call FileInputStream.close() call FileInputStream.close() call FileInputStream.close() call FileInputStream.close() call FileInputStream.close() catch throw new + decl_stmt byte final final final = call java.security.MessageDigest.digest(byte) call java.security.MessageDigest.digest(byte) call java.security.MessageDigest.digest(byte) call java.security.MessageDigest.digest(byte) call java.security.MessageDigest.digest(byte) decl_stmt java.lang.String final final = if ! call java.lang.String.equals(Object) call java.lang.String.equals(Object) call java.lang.String.equals(Object) call java.lang.String.equals(Object) call java.lang.String.equals(Object) + + + + + + = return catch throw new + + else if + else + + + call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() call java.util.regex.Pattern.pattern() decl_stmt java.util.Map < = new <> decl_stmt java.util.List < = new <> for : call FileNameMapper.mapFileName() call FileNameMapper.mapFileName() call FileNameMapper.mapFileName() call FileNameMapper.mapFileName() call FileNameMapper.mapFileName() for : decl_stmt File = new + if call String.exists() call String.exists() call String.exists() call String.exists() call String.exists() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() + + + call String.getPath() call String.getPath() call String.getPath() call String.getPath() call String.getPath() break break else call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() for < : call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() decl_stmt LicenseType = decl_stmt java.lang.String = decl_stmt java.lang.String = call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() - call LicenseType.licenseFileSuffix() call LicenseType.licenseFileSuffix() call LicenseType.licenseFileSuffix() call LicenseType.licenseFileSuffix() call LicenseType.licenseFileSuffix() decl_stmt File = new + call LicenseType.noticeFileSuffix() call LicenseType.noticeFileSuffix() call LicenseType.noticeFileSuffix() call LicenseType.noticeFileSuffix() call LicenseType.noticeFileSuffix() if call File.exists() call File.exists() call File.exists() call File.exists() call File.exists() + call File.getAbsolutePath() call File.getAbsolutePath() call File.getAbsolutePath() call File.getAbsolutePath() call File.getAbsolutePath() else if call LicenseType.isNoticeRequired() call LicenseType.isNoticeRequired() call LicenseType.isNoticeRequired() call LicenseType.isNoticeRequired() call LicenseType.isNoticeRequired() = + + + call File.getAbsolutePath() call File.getAbsolutePath() call File.getAbsolutePath() call File.getAbsolutePath() call File.getAbsolutePath() if call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() call decl Map.isEmpty() = decl_stmt java.lang.StringBuilder = new call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) + + for : call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() return return StringBuilder private static final private static final decl_stmt java.lang.StringBuilder = new for = < ++ call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) & return call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() String BufferedReader private static final private static final decl_stmt java.io.BufferedReader = try = new new new try decl_stmt java.lang.String = call java.io.BufferedReader.readLine(boolean) call java.io.BufferedReader.readLine(boolean) call java.io.BufferedReader.readLine(boolean) call java.io.BufferedReader.readLine(boolean) call java.io.BufferedReader.readLine(boolean) if == || == call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() throw new + return finally call BufferedReader.close() call BufferedReader.close() call BufferedReader.close() call BufferedReader.close() call BufferedReader.close() catch throw new + Matcher private static final private static final if == return decl_stmt java.util.regex.Matcher = call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) return call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches() call java.util.regex.Matcher.matches()