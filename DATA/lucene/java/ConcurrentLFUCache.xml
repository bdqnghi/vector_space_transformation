org.apache.solr.util org.apache.solr.common.util.Cache import org.slf4j.Logger import org.slf4j.LoggerFactory import java.lang.invoke.MethodHandles import java.lang.ref.WeakReference import java.util.LinkedHashMap import java.util.Map import java.util.TreeSet import java.util.concurrent.ConcurrentHashMap import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.atomic.AtomicLong import java.util.concurrent.locks.ReentrantLock import class super super implements decl ConcurrentHashMap int Logger boolean boolean boolean boolean int decl EvictionListener CleanupThread Stats boolean long ReentrantLock public public = decl CacheEntry public public decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() if == if call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() return if = call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() return decl CacheEntry public public decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() if != call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() return return decl CacheEntry decl CacheEntry int public public if == return decl_stmt sun.misc.CacheEntry < = new <> call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() decl_stmt int if == = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() else = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() if call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() else call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() if > && ! if new public public else if != call boolean.wakeThread() call boolean.wakeThread() call boolean.wakeThread() call boolean.wakeThread() call boolean.wakeThread() else return == : public public int decl TreeSet long int private private if ! call boolean.tryLock() call boolean.tryLock() call boolean.tryLock() call boolean.tryLock() call boolean.tryLock() return try decl_stmt long = = = decl_stmt int = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() if <= return decl_stmt int = - decl_stmt java.util.TreeSet < < = new <> for < : call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() = = if >>> if call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() < call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() > if < call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if == call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() for < : finally = call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() decl CacheEntry private private decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() if == return call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() if != call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() decl TreeSet decl Map decl CacheEntry public < public < decl_stmt java.util.Map < = new <> if <= return decl_stmt java.util.TreeSet < < = new <> call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() try for < < : call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() decl_stmt sun.misc.CacheEntry < = = call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() = if call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() < call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if < call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if == call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() finally call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() for < : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() return decl TreeSet decl Map decl CacheEntry public < public < decl_stmt java.util.Map < = new <> if <= return decl_stmt java.util.TreeSet < < = new <> call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() try for < < : call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() decl_stmt sun.misc.CacheEntry < = = call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() call decl CacheEntry.hits() = if call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() < call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if > call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if == call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() finally call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() for < : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() return public public return call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() public public call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() public < < public < < return public public < if == if == return return < : - return < : - public public return public public return public public return + + + + + public public try if != call boolean.stopThread() call boolean.stopThread() call boolean.stopThread() call boolean.stopThread() call boolean.stopThread() finally = public public return public public return - - + public public return - - public public return public public return public public return public public return public public return public public ConcurrentLFUCache public public while synchronized if break try catch if break decl_stmt org.apache.solr.util.ConcurrentLFUCache = if == break call org.apache.solr.util.ConcurrentLFUCache.markAndSweep() call org.apache.solr.util.ConcurrentLFUCache.markAndSweep() call org.apache.solr.util.ConcurrentLFUCache.markAndSweep() call org.apache.solr.util.ConcurrentLFUCache.markAndSweep() call org.apache.solr.util.ConcurrentLFUCache.markAndSweep() synchronized synchronized = protected protected throws try if ! call Logger.error() call Logger.error() call Logger.error() call Logger.error() call Logger.error() finally