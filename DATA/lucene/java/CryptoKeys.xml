org.apache.solr.util javax.crypto.BadPaddingException import javax.crypto.Cipher import javax.crypto.IllegalBlockSizeException import javax.crypto.spec.IvParameterSpec import javax.crypto.spec.SecretKeySpec import java.lang.invoke.MethodHandles import java.nio.ByteBuffer import java.nio.charset.Charset import java.nio.charset.StandardCharsets import java.security.GeneralSecurityException import java.security.InvalidKeyException import java.security.KeyFactory import java.security.KeyPairGenerator import java.security.MessageDigest import java.security.NoSuchAlgorithmException import java.security.PrivateKey import java.security.PublicKey import java.security.SecureRandom import java.security.Signature import java.security.SignatureException import java.security.spec.X509EncodedKeySpec import java.util.Arrays import java.util.HashMap import java.util.Map import org.apache.solr.common.SolrException import org.apache.solr.common.util.Base64 import org.slf4j.Logger import org.slf4j.LoggerFactory import class org.apache.solr.util.CryptoKeys decl Map Exception Logger boolean public public = for < : call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() decl_stmt boolean try = call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) if return catch = call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) call java.util.logging.Logger.info(String) return X509EncodedKeySpec KeyFactory public static public static throws decl_stmt java.security.spec.X509EncodedKeySpec = new decl_stmt java.security.KeyFactory = return call KeyFactory.generatePublic() call KeyFactory.generatePublic() call KeyFactory.generatePublic() call KeyFactory.generatePublic() call KeyFactory.generatePublic() boolean int Signature public static public static throws decl_stmt int = decl_stmt org.apache.solr.update.processor.Signature = try = call sun.reflect.generics.tree.Signature.initVerify(Certificate) call sun.reflect.generics.tree.Signature.initVerify(Certificate) call sun.reflect.generics.tree.Signature.initVerify(Certificate) call sun.reflect.generics.tree.Signature.initVerify(Certificate) call sun.reflect.generics.tree.Signature.initVerify(Certificate) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) decl_stmt boolean = call sun.reflect.generics.tree.Signature.verify(byte,int,int) call sun.reflect.generics.tree.Signature.verify(byte,int,int) call sun.reflect.generics.tree.Signature.verify(byte,int,int) call sun.reflect.generics.tree.Signature.verify(byte,int,int) call sun.reflect.generics.tree.Signature.verify(byte,int,int) return catch finally return decl byte int int int decl byte decl byte int int int decl byte private static private static decl_stmt byte = new decl_stmt byte = new decl_stmt int = decl_stmt byte = new decl_stmt int = = = decl_stmt byte = decl_stmt int = decl_stmt int = decl_stmt int = if == return decl_stmt int = for if ++ > if != = for = < ++ = = if > for if == break if == break ++ = -- ++ if > && != for if == break if == break ++ = -- ++ if == && == break for = < ++ = return decl int Exception public static public static decl_stmt int = new decl_stmt Exception = for : try return catch = throw new decl byte Cipher SecretKeySpec int decl byte int decl byte IvParameterSpec decl byte int int decl byte MessageDigest Charset int int public static public static final final decl_stmt java.nio.charset.Charset final final = decl_stmt int final final = decl_stmt int final final = decl_stmt int final final = decl_stmt int final final = decl_stmt int final final = decl_stmt int final final = + try decl_stmt byte = decl_stmt byte = + decl_stmt byte = decl_stmt Cipher = decl_stmt java.security.MessageDigest = decl_stmt byte final final final = / call Cipher.getBlockSize() call Cipher.getBlockSize() call Cipher.getBlockSize() call Cipher.getBlockSize() call Cipher.getBlockSize() decl_stmt javax.crypto.spec.SecretKeySpec = new decl_stmt javax.crypto.spec.IvParameterSpec = new call Cipher.init() call Cipher.init() call Cipher.init() call Cipher.init() call Cipher.init() decl_stmt byte = call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() return new catch throw new + catch throw new catch throw new KeyFactory X509EncodedKeySpec public static public static try decl_stmt java.security.KeyFactory = decl_stmt java.security.spec.X509EncodedKeySpec = new return call KeyFactory.generatePublic() call KeyFactory.generatePublic() call KeyFactory.generatePublic() call KeyFactory.generatePublic() call KeyFactory.generatePublic() catch throw new Cipher public static public static throws decl_stmt Cipher = try = catch throw new call Cipher.init() call Cipher.init() call Cipher.init() call Cipher.init() call Cipher.init() return call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() public public return public public return Cipher public public try decl_stmt Cipher = call Cipher.init() call Cipher.init() call Cipher.init() call Cipher.init() call Cipher.init() return call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() call Cipher.doFinal() catch throw new Signature public public throws decl_stmt org.apache.solr.update.processor.Signature = try = catch throw new call sun.reflect.generics.tree.Signature.initSign(PrivateKey) call sun.reflect.generics.tree.Signature.initSign(PrivateKey) call sun.reflect.generics.tree.Signature.initSign(PrivateKey) call sun.reflect.generics.tree.Signature.initSign(PrivateKey) call sun.reflect.generics.tree.Signature.initSign(PrivateKey) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) call sun.reflect.generics.tree.Signature.update(byte,int,int) return call sun.reflect.generics.tree.Signature.sign(byte,int,int) call sun.reflect.generics.tree.Signature.sign(byte,int,int) call sun.reflect.generics.tree.Signature.sign(byte,int,int) call sun.reflect.generics.tree.Signature.sign(byte,int,int) call sun.reflect.generics.tree.Signature.sign(byte,int,int) PublicKey RSAKeyPair String decl byte decl byte public static public static throws decl_stmt RSAKeyPair = new call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() decl_stmt PublicKey = call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() call RSAKeyPair.getPublicKeyStr() decl_stmt byte = decl_stmt byte = call RSAKeyPair.encrypt() call RSAKeyPair.encrypt() call RSAKeyPair.encrypt() call RSAKeyPair.encrypt() call RSAKeyPair.encrypt() decl_stmt java.lang.String = + + call RSAKeyPair.signSha256() call RSAKeyPair.signSha256() call RSAKeyPair.signSha256() call RSAKeyPair.signSha256() call RSAKeyPair.signSha256() + new