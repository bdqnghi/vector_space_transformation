org.apache.solr.util org.apache.lucene.util.PriorityQueue import org.apache.solr.common.util.Cache import org.slf4j.Logger import org.slf4j.LoggerFactory import java.util.Arrays import java.util.Collections import java.util.LinkedHashMap import java.util.Map import java.util.TreeSet import java.util.concurrent.ConcurrentHashMap import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.atomic.AtomicLong import java.util.concurrent.locks.ReentrantLock import java.lang.invoke.MethodHandles import java.lang.ref.WeakReference import class super super implements decl EvictionListener decl ConcurrentHashMap int Logger boolean boolean boolean int CleanupThread Stats boolean long ReentrantLock public public = decl CacheEntry public public decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() if == if call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() call int.missCounter() return if = call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() return decl CacheEntry public public decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() if != call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() return return decl CacheEntry decl CacheEntry int public public if == return decl_stmt sun.misc.CacheEntry < = new <> call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() call decl ConcurrentHashMap.put() decl_stmt int if == = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() else = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() if call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() call int.putCounter() else call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() call int.nonLivePutCounter() if > && ! if new public public else if != call boolean.wakeThread() call boolean.wakeThread() call boolean.wakeThread() call boolean.wakeThread() call boolean.wakeThread() else return == : public public long long int Object int int long long long long decl CacheEntry int int int long CacheEntry decl CacheEntry private private if ! call boolean.tryLock() call boolean.tryLock() call boolean.tryLock() call boolean.tryLock() call boolean.tryLock() return try decl_stmt long = = = decl_stmt long = call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() decl_stmt int = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() decl_stmt int = decl_stmt int = decl_stmt long = decl_stmt long = - decl_stmt long = decl_stmt int = decl_stmt int = - decl_stmt long = = = decl_stmt long = call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() call int.accessCounter() decl_stmt int = call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() decl_stmt int = decl_stmt int = decl_stmt long = decl_stmt long = - decl_stmt long = decl_stmt int = decl_stmt int = - decl_stmt int = for < : call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() = decl_stmt long = if > - ++ = else if < + ++ else if < - ++ = = = decl_stmt int = while - > && -- >= = == : = = = - = - = - - for = - >= -- decl_stmt sun.misc.CacheEntry < = decl_stmt long = if > - ++ = - -- = else if < + ++ = - -- else = = if - > = == : = = = - = - = - - decl_stmt PQueue < = new <> for = - >= -- decl_stmt sun.misc.CacheEntry < = decl_stmt long = if > - ++ = else if < + ++ else = - - while call decl CacheEntry.size() call decl CacheEntry.size() call decl CacheEntry.size() call decl CacheEntry.size() call decl CacheEntry.size() > && call decl CacheEntry.size() call decl CacheEntry.size() call decl CacheEntry.size() call decl CacheEntry.size() call decl CacheEntry.size() > decl_stmt sun.misc.CacheEntry = call decl CacheEntry.pop() call decl CacheEntry.pop() call decl CacheEntry.pop() call decl CacheEntry.pop() call decl CacheEntry.pop() = if <= break decl_stmt java.lang.Object = call decl CacheEntry.myInsertWithOverflow() call decl CacheEntry.myInsertWithOverflow() call decl CacheEntry.myInsertWithOverflow() call decl CacheEntry.myInsertWithOverflow() call decl CacheEntry.myInsertWithOverflow() if != = for < : call decl CacheEntry.getValues() call decl CacheEntry.getValues() call decl CacheEntry.getValues() call decl CacheEntry.getValues() call decl CacheEntry.getValues() if == continue ++ = == : = finally = call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() < < < < return protected protected return < decl CacheEntry public < public < < if < return else if > && ! < decl_stmt sun.misc.CacheEntry < = < = return else return decl CacheEntry private private decl_stmt sun.misc.CacheEntry < = call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() if == return call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() call int.evictionCounter() if != call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() call CleanupThread.evictedEntry() decl TreeSet decl Map decl CacheEntry public < public < decl_stmt java.util.Map < = new <> if <= return decl_stmt java.util.TreeSet < < = new <> call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() try for < < : call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() decl_stmt sun.misc.CacheEntry < = = if call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() < call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if < call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.first() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() finally call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() for < : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() return decl TreeSet decl Map decl CacheEntry public < public < decl_stmt java.util.Map < = new <> if <= return decl_stmt java.util.TreeSet < < = new <> call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() call boolean.lock() try for < < : call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() call decl ConcurrentHashMap.entrySet() decl_stmt sun.misc.CacheEntry < = = if call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() call decl TreeSet.size() < call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() else if > call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.remove() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.last() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() call decl TreeSet.add() finally call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() call boolean.unlock() for < : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() return public public return call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() call int.size() public public call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() call decl ConcurrentHashMap.clear() public < < public < < return public public = public public < if == return return < : - public public return public public return public public return + + + + + public public try if != call boolean.stopThread() call boolean.stopThread() call boolean.stopThread() call boolean.stopThread() call boolean.stopThread() finally = public public return public public return - - + public public return - - public public return public public return public public return public public return public public return public public ConcurrentLRUCache public public while synchronized if break try catch if break decl_stmt org.apache.solr.util.ConcurrentLRUCache = if == break call org.apache.solr.util.ConcurrentLRUCache.markAndSweep() call org.apache.solr.util.ConcurrentLRUCache.markAndSweep() call org.apache.solr.util.ConcurrentLRUCache.markAndSweep() call org.apache.solr.util.ConcurrentLRUCache.markAndSweep() call org.apache.solr.util.ConcurrentLRUCache.markAndSweep() synchronized synchronized = protected protected throws try if ! && != call Logger.error() call Logger.error() call Logger.error() call Logger.error() call Logger.error() finally