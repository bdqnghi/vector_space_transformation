org.apache.solr.handler.dataimport org.apache.solr.common.util.XMLErrorLogger import org.apache.solr.common.EmptyEntityResolver import javax.xml.stream.XMLInputFactory import static static javax.xml.stream.XMLStreamConstants.* import javax.xml.stream.XMLStreamException import javax.xml.stream.XMLStreamReader import java.io.IOException import java.io.Reader import java.lang.invoke.MethodHandles import java.util.* import java.util.regex.Matcher import java.util.regex.Pattern import org.slf4j.Logger import org.slf4j.LoggerFactory import class org.apache.solr.handler.dataimport.XPathRecordReader XMLErrorLogger Logger Pattern XMLInputFactory Node int public synchronized public synchronized return public synchronized public synchronized return decl List private private if ! throw new + decl_stmt java.util.List < = if call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.remove() call decl List.remove() call decl List.remove() call decl List.remove() call decl List.remove() call Node.build() call Node.build() call Node.build() call Node.build() call Node.build() call Node.buildOptimise() call Node.buildOptimise() call Node.buildOptimise() call Node.buildOptimise() call Node.buildOptimise() decl List public < < public < < decl_stmt java.util.List final final final < < = new <> new public public < call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() return public public < XMLStreamReader public public try decl_stmt XMLStreamReader = call XMLInputFactory.createXMLStreamReader() call XMLInputFactory.createXMLStreamReader() call XMLInputFactory.createXMLStreamReader() call XMLInputFactory.createXMLStreamReader() call XMLInputFactory.createXMLStreamReader() call Node.parse() call Node.parse() call Node.parse() call Node.parse() call Node.parse() new < new < < catch throw new decl Set decl Set StringBuilder String int decl Set int private private < < < throws decl_stmt java.util.Set < = if = = new <> else if = try if != for : decl_stmt java.lang.String = if != || && ! call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() decl_stmt java.util.Set < = new <> decl_stmt int = - decl_stmt int = decl_stmt java.lang.StringBuilder = new while = if == if > -- else if && != call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() if if != && && ! && ! call decl Set.containsAll() call decl Set.containsAll() call decl Set.containsAll() call decl Set.containsAll() call decl Set.containsAll() for : if ! call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() return else if && == || == || == call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) else if == if ++ else else if == return finally if || ! && ! decl_stmt java.util.Set < = if != for : Node int Node decl Map Node int private private < < < < throws decl_stmt org.apache.lucene.replicator.nrt.Node = decl_stmt java.util.Map < = new <> if != call Node.parse() call Node.parse() call Node.parse() call Node.parse() call Node.parse() return decl_stmt org.apache.lucene.replicator.nrt.Node = do if != = if != call Node.parse() call Node.parse() call Node.parse() call Node.parse() call Node.parse() break for : call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() = != if == decl_stmt int = while != decl_stmt int = if == decl_stmt org.apache.lucene.replicator.nrt.Node = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if != call Node.parse() call Node.parse() call Node.parse() call Node.parse() call Node.parse() else ++ else if == -- String private private < if == return decl_stmt java.lang.String = for : if if == return if return return String private private < < for < : decl_stmt java.lang.String = if == return if != && ! return return private private < < if != for : if if && if != for : private private < < if != decl List private private < if decl_stmt java.util.List < = < if == = new <> call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() else private private = if != = if != for : String Node private private < decl_stmt java.lang.String = if && call java.lang.String.startsWith(String,int) call java.lang.String.startsWith(String,int) call java.lang.String.startsWith(String,int) call java.lang.String.startsWith(String,int) call java.lang.String.startsWith(String,int) if == = new <> = call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.substring(int) call java.lang.String.substring(int) new else if call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() call java.lang.String.length() == = if == = new <> decl_stmt org.apache.lucene.replicator.nrt.Node = if = = = = == else call Node.build() call Node.build() call Node.build() call Node.build() call Node.build() else if == = new <> decl_stmt org.apache.lucene.replicator.nrt.Node = if if = = else = = = = == else call Node.build() call Node.build() call Node.build() call Node.build() call Node.build() decl HashMap int Matcher Node private private < for : if call Node.xpathName() call Node.xpathName() call Node.xpathName() call Node.xpathName() call Node.xpathName() call Node.xpathName() call Node.xpathName() call Node.xpathName() call Node.xpathName() return decl_stmt org.apache.lucene.replicator.nrt.Node = new decl_stmt java.util.regex.Matcher = call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) call java.util.regex.Pattern.matcher(CharSequence) if call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) = call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) decl_stmt int = call java.util.regex.Matcher.start(int) call java.util.regex.Matcher.start(int) call java.util.regex.Matcher.start(int) call java.util.regex.Matcher.start(int) call java.util.regex.Matcher.start(int) while decl_stmt HashMap < = new <> if ! call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) call java.util.regex.Matcher.find(int) break call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) call java.util.regex.Matcher.group(int) = call java.util.regex.Matcher.end(int) call java.util.regex.Matcher.end(int) call java.util.regex.Matcher.end(int) call java.util.regex.Matcher.end(int) call java.util.regex.Matcher.end(int) if == = new <> call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call Node.attribAndValues() call decl HashMap.entrySet() call decl HashMap.entrySet() call decl HashMap.entrySet() call decl HashMap.entrySet() call decl HashMap.entrySet() return decl Map private static < private static < < decl_stmt java.util.Map < = new <> for < : if instanceof call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() new else call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() return decl String StringBuilder int decl List private static < private static < decl_stmt java.util.List < = new <> decl_stmt java.lang.String = for = < ++ decl_stmt java.lang.StringBuilder = new decl_stmt int = while call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) for = < ++ if == ++ if == break ++ call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() return