org.apache.lucene.queryparser.flexible.standard java.io.IOException import java.text.DateFormat import java.text.NumberFormat import java.text.ParseException import java.text.SimpleDateFormat import java.util.Collections import java.util.Date import java.util.HashMap import java.util.Locale import java.util.Map import java.util.Random import java.util.TimeZone import org.apache.lucene.analysis.Analyzer import org.apache.lucene.analysis.MockAnalyzer import org.apache.lucene.document.Document import org.apache.lucene.document.LegacyDoubleField import org.apache.lucene.document.Field import org.apache.lucene.document.FieldType.LegacyNumericType import org.apache.lucene.document.FieldType import org.apache.lucene.document.LegacyFloatField import org.apache.lucene.document.LegacyIntField import org.apache.lucene.document.LegacyLongField import org.apache.lucene.index.IndexReader import org.apache.lucene.index.RandomIndexWriter import org.apache.lucene.queryparser.flexible.core.QueryNodeException import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax import org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat import org.apache.lucene.queryparser.flexible.standard.config.LegacyNumericConfig import org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl import org.apache.lucene.search.IndexSearcher import org.apache.lucene.search.Query import org.apache.lucene.search.TopDocs import org.apache.lucene.store.Directory import org.apache.lucene.util.LuceneTestCase import org.apache.lucene.util.TestUtil import org.junit.AfterClass import org.junit.BeforeClass import org.junit.Test import class org.apache.lucene.queryparser.flexible.standard.TestLegacyNumericQueryParser super super extends StandardQueryParser IndexSearcher decl Map EscapeQuerySyntax int Locale int Analyzer int String IndexReader Directory TimeZone decl int String NumberFormat NumberDateFormat private static private static try return == new catch return int long RandomIndexWriter FieldType SimpleDateFormat Document float long boolean int double decl HashMap LegacyLongField Field decl HashMap decl HashMap public static public static throws = new = new decl_stmt HashMap final final final < = new <> decl_stmt java.text.SimpleDateFormat decl_stmt long decl_stmt boolean decl_stmt int = do if > = = = = = = call java.text.SimpleDateFormat.applyPattern(String) call java.text.SimpleDateFormat.applyPattern(String) call java.text.SimpleDateFormat.applyPattern(String) call java.text.SimpleDateFormat.applyPattern(String) call java.text.SimpleDateFormat.applyPattern(String) call java.text.SimpleDateFormat.toPattern() call java.text.SimpleDateFormat.toPattern() call java.text.SimpleDateFormat.toPattern() call java.text.SimpleDateFormat.toPattern() call java.text.SimpleDateFormat.toPattern() + call SimpleDateFormat.setTimeZone() call SimpleDateFormat.setTimeZone() call SimpleDateFormat.setTimeZone() call SimpleDateFormat.setTimeZone() call SimpleDateFormat.setTimeZone() = new do = = = / * = == &= &= &= - ++ ! = call java.text.NumberFormat.setMaximumFractionDigits(int) call java.text.NumberFormat.setMaximumFractionDigits(int) call java.text.NumberFormat.setMaximumFractionDigits(int) call java.text.NumberFormat.setMaximumFractionDigits(int) call java.text.NumberFormat.setMaximumFractionDigits(int) & + call java.text.NumberFormat.setMinimumFractionDigits(int) call java.text.NumberFormat.setMinimumFractionDigits(int) call java.text.NumberFormat.setMinimumFractionDigits(int) call java.text.NumberFormat.setMinimumFractionDigits(int) call java.text.NumberFormat.setMinimumFractionDigits(int) & + call java.text.NumberFormat.setMaximumIntegerDigits(int) call java.text.NumberFormat.setMaximumIntegerDigits(int) call java.text.NumberFormat.setMaximumIntegerDigits(int) call java.text.NumberFormat.setMaximumIntegerDigits(int) call java.text.NumberFormat.setMaximumIntegerDigits(int) & + call java.text.NumberFormat.setMinimumIntegerDigits(int) call java.text.NumberFormat.setMinimumIntegerDigits(int) call java.text.NumberFormat.setMinimumIntegerDigits(int) call java.text.NumberFormat.setMinimumIntegerDigits(int) call java.text.NumberFormat.setMinimumIntegerDigits(int) & + decl_stmt double decl_stmt long decl_stmt int decl_stmt float while = == while = == while = == while = == call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() = = decl_stmt org.apache.lucene.index.RandomIndexWriter = new new decl_stmt org.apache.lucene.document.Document = new decl_stmt HashMap < = new <> decl_stmt HashMap < = new <> call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.setLegacyNumericConfigMap(Map) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.setLegacyNumericConfigMap(Map) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.setLegacyNumericConfigMap(Map) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.setLegacyNumericConfigMap(Map) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.setLegacyNumericConfigMap(Map) for : call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() new decl_stmt org.apache.solr.schema.FieldType = new call org.apache.solr.schema.FieldType.setNumericType(LegacyNumericType) call org.apache.solr.schema.FieldType.setNumericType(LegacyNumericType) call org.apache.solr.schema.FieldType.setNumericType(LegacyNumericType) call org.apache.solr.schema.FieldType.setNumericType(LegacyNumericType) call org.apache.solr.schema.FieldType.setNumericType(LegacyNumericType) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.freeze() call org.apache.solr.schema.FieldType.freeze() call org.apache.solr.schema.FieldType.freeze() call org.apache.solr.schema.FieldType.freeze() call org.apache.solr.schema.FieldType.freeze() decl_stmt org.apache.solr.handler.dataimport.config.Field final final switch case = new break case = new break case = new break case = new break default: = call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() new decl_stmt org.apache.solr.schema.FieldType = new call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setStored(boolean) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) call org.apache.solr.schema.FieldType.setNumericPrecisionStep(int) decl_stmt LegacyLongField = new call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call decl HashMap.put() call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) call org.apache.lucene.document.Document.add(IndexableField) for : if + call org.apache.lucene.index.RandomIndexWriter.addDocument(Iterable) call org.apache.lucene.index.RandomIndexWriter.addDocument(Iterable) call org.apache.lucene.index.RandomIndexWriter.addDocument(Iterable) call org.apache.lucene.index.RandomIndexWriter.addDocument(Iterable) call org.apache.lucene.index.RandomIndexWriter.addDocument(Iterable) = call org.apache.lucene.index.RandomIndexWriter.getReader() call org.apache.lucene.index.RandomIndexWriter.getReader() call org.apache.lucene.index.RandomIndexWriter.getReader() call org.apache.lucene.index.RandomIndexWriter.getReader() call org.apache.lucene.index.RandomIndexWriter.getReader() = call org.apache.lucene.index.RandomIndexWriter.close() call org.apache.lucene.index.RandomIndexWriter.close() call org.apache.lucene.index.RandomIndexWriter.close() call org.apache.lucene.index.RandomIndexWriter.close() call org.apache.lucene.index.RandomIndexWriter.close() Number private static private static if == return switch case return call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() case decl_stmt java.lang.Number = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if || call java.lang.String.equals(Object) call java.lang.String.equals(Object) call java.lang.String.equals(Object) call java.lang.String.equals(Object) call java.lang.String.equals(Object) = - call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() else if = - call Number.doubleValue() call Number.doubleValue() call Number.doubleValue() call Number.doubleValue() call Number.doubleValue() else if = - call Number.floatValue() call Number.floatValue() call Number.floatValue() call Number.floatValue() call Number.floatValue() else if = - call Number.intValue() call Number.intValue() call Number.intValue() call Number.intValue() call Number.intValue() else throw new + return default: return Number private static private static < decl_stmt java.lang.Number = call Number.doubleValue() call Number.doubleValue() call Number.doubleValue() call Number.doubleValue() call Number.doubleValue() = call Number.intValue() call Number.intValue() call Number.intValue() call Number.intValue() call Number.intValue() = call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() = call Number.floatValue() call Number.floatValue() call Number.floatValue() call Number.floatValue() call Number.floatValue() = call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() private static private static return public public throws public public throws public public throws public public throws public public throws public public throws String String Number String String Number String String StringBuilder public public throws decl_stmt java.lang.StringBuilder = new decl_stmt java.lang.String = : decl_stmt java.lang.String = : for : decl_stmt java.lang.String = decl_stmt java.lang.String = call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) decl_stmt java.lang.Number = decl_stmt java.lang.Number = decl_stmt java.lang.String decl_stmt java.lang.String if != = call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) new call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() else = if != = call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) new call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() call Number.longValue() else = call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() StringBuilder String String public public throws decl_stmt java.lang.StringBuilder = new for : decl_stmt java.lang.String = call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) decl_stmt java.lang.String = call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) new call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() StringBuilder String String public public throws decl_stmt java.lang.StringBuilder = new for : decl_stmt java.lang.String = call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) decl_stmt java.lang.String = call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) call org.apache.lucene.queryparser.flexible.standard.config.NumberDateFormat.format(long,StringBuffer,FieldPosition) new call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() String Query TopDocs private private throws if + decl_stmt org.apache.lucene.search.Query = call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.parse(String,String) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.parse(String,String) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.parse(String,String) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.parse(String,String) call org.apache.lucene.queryparser.flexible.standard.StandardQueryParser.parse(String,String) if + decl_stmt org.apache.lucene.search.TopDocs = call org.apache.lucene.search.IndexSearcher.search(Query,int) call org.apache.lucene.search.IndexSearcher.search(Query,int) call org.apache.lucene.search.IndexSearcher.search(Query,int) call org.apache.lucene.search.IndexSearcher.search(Query,int) call org.apache.lucene.search.IndexSearcher.search(Query,int) decl_stmt java.lang.String = + + + + + + if private static private static return == : call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call EscapeQuerySyntax.escape() call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) private static private static throws return call java.text.NumberFormat.parse(String) call java.text.NumberFormat.parse(String) call java.text.NumberFormat.parse(String) call java.text.NumberFormat.parse(String) call java.text.NumberFormat.parse(String) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) call java.text.NumberFormat.format(double) public static public static throws = call org.apache.lucene.index.IndexReader.close() call org.apache.lucene.index.IndexReader.close() call org.apache.lucene.index.IndexReader.close() call org.apache.lucene.index.IndexReader.close() call org.apache.lucene.index.IndexReader.close() = call Directory.close() call Directory.close() call Directory.close() call Directory.close() call Directory.close() = = = = = = =