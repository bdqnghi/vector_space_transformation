org.apache.lucene.codecs.lucene50 static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.CONST_COMPRESSED import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.DELTA_COMPRESSED import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.INDIRECT import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.PATCHED_BITSET import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.PATCHED_TABLE import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.TABLE_COMPRESSED import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.UNCOMPRESSED import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.VERSION_CURRENT import static static org.apache.lucene.codecs.lucene50.Lucene50NormsFormat.VERSION_START import java.io.IOException import java.util.ArrayList import java.util.Collection import java.util.Collections import java.util.HashMap import java.util.List import java.util.Map import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.atomic.AtomicLong import org.apache.lucene.codecs.CodecUtil import org.apache.lucene.codecs.NormsProducer import org.apache.lucene.index.CorruptIndexException import org.apache.lucene.index.FieldInfo import org.apache.lucene.index.FieldInfos import org.apache.lucene.index.IndexFileNames import org.apache.lucene.index.NumericDocValues import org.apache.lucene.index.SegmentReadState import org.apache.lucene.store.ChecksumIndexInput import org.apache.lucene.store.IndexInput import org.apache.lucene.util.Accountable import org.apache.lucene.util.Accountables import org.apache.lucene.util.IOUtils import org.apache.lucene.util.RamUsageEstimator import org.apache.lucene.util.SparseFixedBitSet import org.apache.lucene.util.packed.BlockPackedReader import org.apache.lucene.util.packed.MonotonicBlockPackedReader import org.apache.lucene.util.packed.PackedInts import class annotation org.apache.lucene.codecs.lucene50.Lucene50NormsProducer super super extends int AtomicInteger decl Map boolean decl Map AtomicLong IndexInput FieldInfo NormsEntry int private private throws decl_stmt int = while != - decl_stmt org.apache.lucene.index.FieldInfo = if == throw new + else if ! call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() throw new + decl_stmt NormsEntry = call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() = NormsEntry private private throws decl_stmt NormsEntry = new = = = switch case case case case break case case case if != throw new + + = break default: throw new + return Norms public synchronized public synchronized throws decl_stmt Norms = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if == = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if ! call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicLong.addAndGet(long) call java.util.concurrent.atomic.AtomicLong.addAndGet(long) call java.util.concurrent.atomic.AtomicLong.addAndGet(long) call java.util.concurrent.atomic.AtomicLong.addAndGet(long) call java.util.concurrent.atomic.AtomicLong.addAndGet(long) call Norms.ramBytesUsed() call Norms.ramBytesUsed() call Norms.ramBytesUsed() call Norms.ramBytesUsed() call Norms.ramBytesUsed() return public public return call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() public synchronized < public synchronized < return public public throws int int int long MonotonicBlockPackedReader decl PackedInts int BlockPackedReader Norms int Norms int int int byte decl List decl List decl Reader int SparseFixedBitSet int private private throws switch case decl_stmt long final final = return new public public return public public return public public return case call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() decl_stmt byte final final = new call IndexInput.readBytes() call IndexInput.readBytes() call IndexInput.readBytes() call IndexInput.readBytes() call IndexInput.readBytes() return new public public return public public return public public return case call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt org.apache.lucene.util.packed.BlockPackedReader final final = new return new public public return call BlockPackedReader.get() call BlockPackedReader.get() call BlockPackedReader.get() call BlockPackedReader.get() call BlockPackedReader.get() public public return call org.apache.lucene.util.packed.BlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.BlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.BlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.BlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.BlockPackedReader.ramBytesUsed() public < public < return public public return case call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int final final = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int final final = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() if != && != && != throw new + decl_stmt int = << decl_stmt byte final final = new decl_stmt int final final = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() for = < ++ = call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) for = < ++ = decl_stmt java.io.Reader final final final final final = return new public public return int call byte.get() call byte.get() call byte.get() call byte.get() call byte.get() public public return + call byte.ramBytesUsed() call byte.ramBytesUsed() call byte.ramBytesUsed() call byte.ramBytesUsed() call byte.ramBytesUsed() public < public < return public public return case call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() decl_stmt long final final = call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt org.apache.lucene.util.packed.MonotonicBlockPackedReader final final = decl_stmt Norms final final = decl_stmt int final final = - return new public public decl_stmt int = decl_stmt int = while <= decl_stmt int = + >>> decl_stmt long = call int.get() call int.get() call int.get() call int.get() call int.get() if < = + else if > = - else return call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() return public public return call int.ramBytesUsed() call int.ramBytesUsed() call int.ramBytesUsed() call int.ramBytesUsed() call int.ramBytesUsed() + call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() public < public < decl_stmt java.util.List < = new <> call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() return public public return case call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() decl_stmt long final final = call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) call org.apache.lucene.store.IndexInput.readLong(long) decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt org.apache.lucene.util.packed.MonotonicBlockPackedReader = decl_stmt org.apache.lucene.util.SparseFixedBitSet final final = new for = < call int.size() call int.size() call int.size() call int.size() call int.size() ++ decl_stmt int = int call int.get() call int.get() call int.get() call int.get() call int.get() call MonotonicBlockPackedReader.set() call MonotonicBlockPackedReader.set() call MonotonicBlockPackedReader.set() call MonotonicBlockPackedReader.set() call MonotonicBlockPackedReader.set() decl_stmt Norms = return new public public if call org.apache.lucene.util.packed.MonotonicBlockPackedReader.get(long) call org.apache.lucene.util.packed.MonotonicBlockPackedReader.get(long) call org.apache.lucene.util.packed.MonotonicBlockPackedReader.get(long) call org.apache.lucene.util.packed.MonotonicBlockPackedReader.get(long) call org.apache.lucene.util.packed.MonotonicBlockPackedReader.get(long) return call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() else return public public return call org.apache.lucene.util.packed.MonotonicBlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.MonotonicBlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.MonotonicBlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.MonotonicBlockPackedReader.ramBytesUsed() call org.apache.lucene.util.packed.MonotonicBlockPackedReader.ramBytesUsed() + call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() public < public < decl_stmt java.util.List < = new <> call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() return public public return case call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() call IndexInput.seek() decl_stmt int = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int final final = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt int final final = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() if != && != throw new + decl_stmt int final final = << decl_stmt int final final = call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() call IndexInput.readVInt() decl_stmt byte final final = new assert + == for = < ++ = call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) call org.apache.lucene.store.IndexInput.readByte(long) decl_stmt java.io.Reader final final final final final = decl_stmt Norms final final = return new public public decl_stmt int = int call byte.get() call byte.get() call byte.get() call byte.get() call byte.get() try return catch return call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() call decl PackedInts.get() public public return + call byte.ramBytesUsed() call byte.ramBytesUsed() call byte.ramBytesUsed() call byte.ramBytesUsed() call byte.ramBytesUsed() + call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() call decl PackedInts.ramBytesUsed() public < public < decl_stmt java.util.List < = new <> call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() call Norms.add() return public public return default: throw new public public return public public return public public return public public return public public return public public return public public return public public return public < public < return public public return public public return int public public return + public < public < return public public return int long int int public public decl_stmt int = decl_stmt int = while <= decl_stmt int = + >>> decl_stmt long = if < = + else if > = - else return return public public return + decl List public < public < decl_stmt java.util.List < = new <> call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() return public public return public public if return else return public public return + decl List public < public < decl_stmt java.util.List < = new <> call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() return public public return int public public decl_stmt int = int try return catch return public public return + + decl List public < public < decl_stmt java.util.List < = new <> call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() return public public return public public throws call IndexInput.close() call IndexInput.close() call IndexInput.close() call IndexInput.close() call IndexInput.close() public synchronized public synchronized throws return new public public return + + call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() + + call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() +