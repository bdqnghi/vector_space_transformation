org.apache.solr.core org.apache.lucene.index.LeafReaderContext import org.apache.lucene.queries.function.FunctionValues import org.apache.lucene.queries.function.ValueSource import org.apache.lucene.queries.function.docvalues.DoubleDocValues import org.apache.lucene.queries.function.valuesource.DoubleConstValueSource import org.apache.solr.search.FunctionQParser import org.apache.solr.search.SyntaxError import org.apache.solr.search.ValueSourceParser import java.io.IOException import java.util.Map import java.util.concurrent.ConcurrentMap import java.util.concurrent.ConcurrentHashMap import java.util.concurrent.atomic.AtomicInteger import class org.apache.solr.core.CountUsageValueSourceParser super super extends decl ConcurrentMap public static public static call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() call decl ConcurrentMap.clear() AtomicInteger public static public static decl_stmt java.util.concurrent.atomic.AtomicInteger = call decl ConcurrentMap.remove() call decl ConcurrentMap.remove() call decl ConcurrentMap.remove() call decl ConcurrentMap.remove() call decl ConcurrentMap.remove() if == throw new + return call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() AtomicInteger double String public public throws decl_stmt java.lang.String = decl_stmt double = decl_stmt java.util.concurrent.atomic.AtomicInteger = new if != call decl ConcurrentMap.putIfAbsent() call decl ConcurrentMap.putIfAbsent() call decl ConcurrentMap.putIfAbsent() call decl ConcurrentMap.putIfAbsent() call decl ConcurrentMap.putIfAbsent() throw new + return new public public throws return new public public return public public return