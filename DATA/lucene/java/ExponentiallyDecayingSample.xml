org.apache.solr.util.stats java.util.ArrayList import java.util.Random import java.util.concurrent.ConcurrentSkipListMap import java.util.concurrent.TimeUnit import java.util.concurrent.atomic.AtomicLong import java.util.concurrent.locks.ReentrantReadWriteLock import static static java.lang.Math.exp import static static java.lang.Math.min import class org.apache.solr.util.stats.ExponentiallyDecayingSample super super implements AtomicLong int Clock ReentrantReadWriteLock long Random AtomicLong decl ConcurrentSkipListMap long double public public try call decl ConcurrentSkipListMap.clear() call decl ConcurrentSkipListMap.clear() call decl ConcurrentSkipListMap.clear() call decl ConcurrentSkipListMap.clear() call decl ConcurrentSkipListMap.clear() call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) = call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() + finally public public return int call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() public public double Double long public public try decl_stmt double final final = - / call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() call java.util.Random.nextDouble() decl_stmt long final final = call java.util.concurrent.atomic.AtomicLong.incrementAndGet() call java.util.concurrent.atomic.AtomicLong.incrementAndGet() call java.util.concurrent.atomic.AtomicLong.incrementAndGet() call java.util.concurrent.atomic.AtomicLong.incrementAndGet() call java.util.concurrent.atomic.AtomicLong.incrementAndGet() if <= call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() else decl_stmt java.lang.Double = call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() if < if call decl ConcurrentSkipListMap.putIfAbsent() call decl ConcurrentSkipListMap.putIfAbsent() call decl ConcurrentSkipListMap.putIfAbsent() call decl ConcurrentSkipListMap.putIfAbsent() call decl ConcurrentSkipListMap.putIfAbsent() == while call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() == = call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() call decl ConcurrentSkipListMap.firstKey() finally long long private private decl_stmt long final final = call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() call org.apache.solr.util.stats.Clock.getTick() decl_stmt long final final = call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() if >= public public try return new call decl ConcurrentSkipListMap.values() call decl ConcurrentSkipListMap.values() call decl ConcurrentSkipListMap.values() call decl ConcurrentSkipListMap.values() call decl ConcurrentSkipListMap.values() finally private private return call org.apache.solr.util.stats.Clock.getTime() call org.apache.solr.util.stats.Clock.getTime() call org.apache.solr.util.stats.Clock.getTime() call org.apache.solr.util.stats.Clock.getTime() call org.apache.solr.util.stats.Clock.getTime() private private return * decl ArrayList Long long private private if call java.util.concurrent.atomic.AtomicLong.compareAndSet(long,long) call java.util.concurrent.atomic.AtomicLong.compareAndSet(long,long) call java.util.concurrent.atomic.AtomicLong.compareAndSet(long,long) call java.util.concurrent.atomic.AtomicLong.compareAndSet(long,long) call java.util.concurrent.atomic.AtomicLong.compareAndSet(long,long) + try decl_stmt long final final = = decl_stmt java.util.ArrayList final final final < = new <> call decl ConcurrentSkipListMap.keySet() call decl ConcurrentSkipListMap.keySet() call decl ConcurrentSkipListMap.keySet() call decl ConcurrentSkipListMap.keySet() call decl ConcurrentSkipListMap.keySet() for : decl_stmt java.lang.Long final final = call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.remove() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() call decl ConcurrentSkipListMap.put() * - * - call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call java.util.concurrent.atomic.AtomicLong.set(long) call decl ConcurrentSkipListMap.size() call decl ConcurrentSkipListMap.size() call decl ConcurrentSkipListMap.size() call decl ConcurrentSkipListMap.size() call decl ConcurrentSkipListMap.size() finally private private call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() private private call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() call java.util.concurrent.locks.ReentrantReadWriteLock.writeLock() private private call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() private private call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock() call java.util.concurrent.locks.ReentrantReadWriteLock.readLock()