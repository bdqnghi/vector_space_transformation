org.apache.lucene.index java.util.Arrays import java.util.concurrent.atomic.AtomicReferenceFieldUpdater import java.util.concurrent.locks.ReentrantLock import org.apache.lucene.index.DocValuesUpdate.BinaryDocValuesUpdate import org.apache.lucene.index.DocValuesUpdate.NumericDocValuesUpdate import org.apache.lucene.search.Query import org.apache.lucene.util.Accountable import org.apache.lucene.util.BytesRef import class org.apache.lucene.index.DocumentsWriterDeleteQueue super super implements decl AtomicReferenceFieldUpdater long ReentrantLock decl Node BufferedUpdates DeleteSlice new new new TermNode decl_stmt TermNode final final = new = assert != : decl Node decl Node < while decl_stmt org.apache.lucene.replicator.nrt.Node final final final < = decl_stmt org.apache.lucene.replicator.nrt.Node final final final < = if == if != call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() else if call decl Node.casNext() call decl Node.casNext() call decl Node.casNext() call decl Node.casNext() call decl Node.casNext() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() call decl AtomicReferenceFieldUpdater.compareAndSet() return call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() try return call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() || ! call DeleteSlice.isEmpty() call DeleteSlice.isEmpty() call DeleteSlice.isEmpty() call DeleteSlice.isEmpty() call DeleteSlice.isEmpty() || != || != finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() if call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() try if call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() decl Node FrozenBufferedUpdates call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() decl_stmt org.apache.lucene.replicator.nrt.Node final final final < = if != = try if != = call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() decl_stmt org.apache.lucene.index.FrozenBufferedUpdates final final = new call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() return finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() return new if != = return return decl Node if == return decl_stmt org.apache.lucene.replicator.nrt.Node < = do = assert != : call decl Node.apply() call decl Node.apply() call decl Node.apply() call decl Node.apply() call decl Node.apply() != = return == return == public public return call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() call BufferedUpdates.numTermDeletes() decl Node call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() try decl_stmt org.apache.lucene.replicator.nrt.Node final final final < = = = call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() call org.apache.lucene.index.BufferedUpdates.clear() finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() throw new < < return public public return + for : for : public public return + for : switch case new break case new break default: throw new + StringBuilder public public decl_stmt java.lang.StringBuilder = new call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) if > call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) for : call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call java.lang.StringBuilder.append(boolean) call StringBuilder.setCharAt() call StringBuilder.setCharAt() call StringBuilder.setCharAt() call StringBuilder.setCharAt() call StringBuilder.setCharAt() call StringBuilder.length() call StringBuilder.length() call StringBuilder.length() call StringBuilder.length() call StringBuilder.length() - return call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() call java.lang.StringBuilder.toString() decl Node private private call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() decl_stmt org.apache.lucene.replicator.nrt.Node final final final < = try if != = call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() call DeleteSlice.apply() return call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() call org.apache.lucene.index.BufferedUpdates.any() finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() public public call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() try return call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() call BufferedUpdates.terms() finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() public public return call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() call BufferedUpdates.bytesUsed() public public return + +