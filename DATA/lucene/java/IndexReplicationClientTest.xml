org.apache.lucene.replicator java.io.Closeable import java.io.IOException import java.util.HashMap import java.util.concurrent.Callable import java.util.concurrent.atomic.AtomicInteger import org.apache.lucene.document.Document import org.apache.lucene.index.DirectoryReader import org.apache.lucene.index.IndexWriter import org.apache.lucene.index.IndexWriterConfig import org.apache.lucene.index.SnapshotDeletionPolicy import org.apache.lucene.replicator.ReplicationClient.ReplicationHandler import org.apache.lucene.replicator.ReplicationClient.SourceDirectoryFactory import org.apache.lucene.store.Directory import org.apache.lucene.store.MockDirectoryWrapper import org.apache.lucene.util.IOUtils import org.apache.lucene.util.TestUtil import org.apache.lucene.util.ThreadInterruptedException import org.junit.After import org.junit.Before import org.junit.Test import class org.apache.lucene.replicator.IndexReplicationClientTest super super extends MockDirectoryWrapper String ReplicationHandler IndexReadyCallback IndexWriter ReplicationClient Replicator SourceDirectoryFactory DirectoryReader long public public throws if == = = else decl_stmt org.apache.lucene.index.DirectoryReader = decl_stmt long = call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() + + + > = = return public public throws int DirectoryReader private private throws while call ReplicationHandler.isUpdateThreadAlive() call ReplicationHandler.isUpdateThreadAlive() call ReplicationHandler.isUpdateThreadAlive() call ReplicationHandler.isUpdateThreadAlive() call ReplicationHandler.isUpdateThreadAlive() try catch throw new try decl_stmt org.apache.lucene.index.DirectoryReader = try decl_stmt int = call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() if == return else if + + + + + call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() finally call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() catch private private final final throws call IndexReadyCallback.addDocument() call IndexReadyCallback.addDocument() call IndexReadyCallback.addDocument() call IndexReadyCallback.addDocument() call IndexReadyCallback.addDocument() new call IndexReadyCallback.setCommitData() call IndexReadyCallback.setCommitData() call IndexReadyCallback.setCommitData() call IndexReadyCallback.setCommitData() call IndexReadyCallback.setCommitData() new < call IndexReadyCallback.commit() call IndexReadyCallback.commit() call IndexReadyCallback.commit() call IndexReadyCallback.commit() call IndexReadyCallback.commit() return new IndexWriterConfig public public throws = = = new = new = new = new = new decl_stmt org.apache.lucene.index.IndexWriterConfig = call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) call org.apache.lucene.index.IndexWriterConfig.setIndexDeletionPolicy(IndexDeletionPolicy) new call org.apache.lucene.index.IndexWriterConfig.getIndexDeletionPolicy() call org.apache.lucene.index.IndexWriterConfig.getIndexDeletionPolicy() call org.apache.lucene.index.IndexWriterConfig.getIndexDeletionPolicy() call org.apache.lucene.index.IndexWriterConfig.getIndexDeletionPolicy() call org.apache.lucene.index.IndexWriterConfig.getIndexDeletionPolicy() = new public public throws call IndexReadyCallback.close() call IndexReadyCallback.close() call IndexReadyCallback.close() call IndexReadyCallback.close() call IndexReadyCallback.close() public public throws call IndexWriter.currentVersion() call IndexWriter.currentVersion() call IndexWriter.currentVersion() call IndexWriter.currentVersion() call IndexWriter.currentVersion() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() public public throws call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() public public throws call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.stopUpdateThread() call ReplicationHandler.stopUpdateThread() call ReplicationHandler.stopUpdateThread() call ReplicationHandler.stopUpdateThread() call ReplicationHandler.stopUpdateThread() call ReplicationHandler.close() call ReplicationHandler.close() call ReplicationHandler.close() call ReplicationHandler.close() call ReplicationHandler.close() = new call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() SourceDirectoryFactory int int MockDirectoryWrapper long AtomicInteger Directory Directory int DirectoryReader double public public throws call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.updateNow() call ReplicationHandler.close() call ReplicationHandler.close() call ReplicationHandler.close() call ReplicationHandler.close() call ReplicationHandler.close() call String.close() call String.close() call String.close() call String.close() call String.close() call Replicator.setPreventDoubleWrite() call Replicator.setPreventDoubleWrite() call Replicator.setPreventDoubleWrite() call Replicator.setPreventDoubleWrite() call Replicator.setPreventDoubleWrite() decl_stmt SourceDirectoryFactory final final = decl_stmt java.util.concurrent.atomic.AtomicInteger final final = new = new decl_stmt long private = = decl_stmt double private = = public public throws call SourceDirectoryFactory.cleanupSession() call SourceDirectoryFactory.cleanupSession() call SourceDirectoryFactory.cleanupSession() call SourceDirectoryFactory.cleanupSession() call SourceDirectoryFactory.cleanupSession() public public throws decl_stmt org.apache.lucene.store.Directory = call SourceDirectoryFactory.getDirectory() call SourceDirectoryFactory.getDirectory() call SourceDirectoryFactory.getDirectory() call SourceDirectoryFactory.getDirectory() call SourceDirectoryFactory.getDirectory() if && call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() > decl_stmt org.apache.lucene.store.MockDirectoryWrapper = new call int.setRandomIOExceptionRateOnOpen() call int.setRandomIOExceptionRateOnOpen() call int.setRandomIOExceptionRateOnOpen() call int.setRandomIOExceptionRateOnOpen() call int.setRandomIOExceptionRateOnOpen() call int.setMaxSizeInBytes() call int.setMaxSizeInBytes() call int.setMaxSizeInBytes() call int.setMaxSizeInBytes() call int.setMaxSizeInBytes() call int.setRandomIOExceptionRate() call int.setRandomIOExceptionRate() call int.setRandomIOExceptionRate() call int.setRandomIOExceptionRate() call int.setRandomIOExceptionRate() call int.setCheckIndexOnClose() call int.setCheckIndexOnClose() call int.setCheckIndexOnClose() call int.setCheckIndexOnClose() call int.setCheckIndexOnClose() *= /= return if call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() > && call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() *= /= else call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() return = new new < public public throws if < && call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() > throw new return = new protected protected if instanceof if + try decl_stmt org.apache.lucene.index.DirectoryReader = call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() try decl_stmt int = call int.numDocs() call int.numDocs() call int.numDocs() call int.numDocs() call int.numDocs() decl_stmt int = call int.getIndexCommit() call int.getIndexCommit() call int.getIndexCommit() call int.getIndexCommit() call int.getIndexCommit() finally call int.close() call int.close() call int.close() call int.close() call int.close() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() catch throw new finally call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() assert call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() >= : + call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() if if call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() == else + call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() else if instanceof throw throw new call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() call ReplicationHandler.startUpdateThread() decl_stmt org.apache.lucene.store.Directory final final = call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() decl_stmt int = for = < ++ call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call SourceDirectoryFactory.publish() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() public public throws MockDirectoryWrapper Directory public public throws decl_stmt org.apache.lucene.store.Directory = if && > decl_stmt org.apache.lucene.store.MockDirectoryWrapper = new call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRateOnOpen(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRateOnOpen(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRateOnOpen(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRateOnOpen(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRateOnOpen(double) call MockDirectoryWrapper.setMaxSizeInBytes() call MockDirectoryWrapper.setMaxSizeInBytes() call MockDirectoryWrapper.setMaxSizeInBytes() call MockDirectoryWrapper.setMaxSizeInBytes() call MockDirectoryWrapper.setMaxSizeInBytes() call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRate(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRate(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRate(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRate(double) call org.apache.lucene.store.MockDirectoryWrapper.setRandomIOExceptionRate(double) call MockDirectoryWrapper.setCheckIndexOnClose() call MockDirectoryWrapper.setCheckIndexOnClose() call MockDirectoryWrapper.setCheckIndexOnClose() call MockDirectoryWrapper.setCheckIndexOnClose() call MockDirectoryWrapper.setCheckIndexOnClose() *= /= return if > && call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() *= /= else call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setMaxSizeInBytes() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRate() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() call Replicator.setRandomIOExceptionRateOnOpen() return public public throws if < && > throw new return int int DirectoryReader protected protected if instanceof if + try decl_stmt org.apache.lucene.index.DirectoryReader = call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() try decl_stmt int = call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() call DirectoryReader.numDocs() decl_stmt int = call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() call DirectoryReader.getIndexCommit() finally call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call DirectoryReader.close() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() call Replicator.getDelegate() catch throw new finally assert >= : + if if == else + else if instanceof throw throw new