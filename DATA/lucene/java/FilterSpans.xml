org.apache.lucene.search.spans java.io.IOException import java.util.Objects import org.apache.lucene.search.TwoPhaseIterator import class org.apache.lucene.search.spans.FilterSpans super super extends int boolean Spans int public final public final throws while decl_stmt int = call Spans.nextDoc() call Spans.nextDoc() call Spans.nextDoc() call Spans.nextDoc() call Spans.nextDoc() if == return else if return int public final public final throws decl_stmt int = call Spans.advance() call Spans.advance() call Spans.advance() call Spans.advance() call Spans.advance() while != if break = call Spans.nextDoc() call Spans.nextDoc() call Spans.nextDoc() call Spans.nextDoc() call Spans.nextDoc() return public final public final return call Spans.docID() call Spans.docID() call Spans.docID() call Spans.docID() call Spans.docID() public final public final throws if = return for = call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() if == return switch case return case break case return = public final public final return - : public final public final return - : != call Spans.endPosition() call Spans.endPosition() call Spans.endPosition() call Spans.endPosition() call Spans.endPosition() : public public return call Spans.width() call Spans.width() call Spans.width() call Spans.width() call Spans.width() public public throws call Spans.collect() call Spans.collect() call Spans.collect() call Spans.collect() call Spans.collect() public final public final return call Spans.cost() call Spans.cost() call Spans.cost() call Spans.cost() call Spans.cost() public public return + call sun.java2d.Spans.toString() call sun.java2d.Spans.toString() call sun.java2d.Spans.toString() call sun.java2d.Spans.toString() call sun.java2d.Spans.toString() + TwoPhaseIterator public final public final decl_stmt org.apache.lucene.search.TwoPhaseIterator = call org.apache.lucene.search.spans.Spans.asTwoPhaseIterator() call org.apache.lucene.search.spans.Spans.asTwoPhaseIterator() call org.apache.lucene.search.spans.Spans.asTwoPhaseIterator() call org.apache.lucene.search.spans.Spans.asTwoPhaseIterator() call org.apache.lucene.search.spans.Spans.asTwoPhaseIterator() if != return new call org.apache.lucene.search.TwoPhaseIterator.approximation() call org.apache.lucene.search.TwoPhaseIterator.approximation() call org.apache.lucene.search.TwoPhaseIterator.approximation() call org.apache.lucene.search.TwoPhaseIterator.approximation() call org.apache.lucene.search.TwoPhaseIterator.approximation() public public throws return call TwoPhaseIterator.matches() call TwoPhaseIterator.matches() call TwoPhaseIterator.matches() call TwoPhaseIterator.matches() call TwoPhaseIterator.matches() && public public return call TwoPhaseIterator.matchCost() call TwoPhaseIterator.matchCost() call TwoPhaseIterator.matchCost() call TwoPhaseIterator.matchCost() call TwoPhaseIterator.matchCost() public public return + + + + else return new public public throws return public public return call Spans.positionsCost() call Spans.positionsCost() call Spans.positionsCost() call Spans.positionsCost() call Spans.positionsCost() public public return + + public public throws return && public public return public public return + + + + public public throws return public public return call Spans.positionsCost() call Spans.positionsCost() call Spans.positionsCost() call Spans.positionsCost() call Spans.positionsCost() public public return + + public public throw new private final private final throws = = call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() assert != for switch case = return case = call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() call Spans.nextStartPosition() if != break case = - return