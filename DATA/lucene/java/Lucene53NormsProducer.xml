org.apache.lucene.codecs.lucene53 static static org.apache.lucene.codecs.lucene53.Lucene53NormsFormat.VERSION_CURRENT import static static org.apache.lucene.codecs.lucene53.Lucene53NormsFormat.VERSION_START import java.io.IOException import java.util.HashMap import java.util.Map import org.apache.lucene.codecs.CodecUtil import org.apache.lucene.codecs.NormsProducer import org.apache.lucene.index.CorruptIndexException import org.apache.lucene.index.FieldInfo import org.apache.lucene.index.FieldInfos import org.apache.lucene.index.IndexFileNames import org.apache.lucene.index.NumericDocValues import org.apache.lucene.index.SegmentReadState import org.apache.lucene.store.ChecksumIndexInput import org.apache.lucene.store.IndexInput import org.apache.lucene.store.RandomAccessInput import org.apache.lucene.util.IOUtils import class org.apache.lucene.codecs.lucene53.Lucene53NormsProducer super super extends decl Map IndexInput int FieldInfo NormsEntry int private private throws decl_stmt int = while != - decl_stmt org.apache.lucene.index.FieldInfo = if == throw new + else if ! call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() call org.apache.lucene.index.FieldInfo.hasNorms() throw new + decl_stmt NormsEntry = new = switch case case case case case break default: throw new + + + = call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() = NormsEntry RandomAccessInput long public public throws decl_stmt NormsEntry final final = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if == decl_stmt long final final = return new public public return decl_stmt org.apache.lucene.store.RandomAccessInput synchronized switch case = call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() return new public public try return call RandomAccessInput.readByte() call RandomAccessInput.readByte() call RandomAccessInput.readByte() call RandomAccessInput.readByte() call RandomAccessInput.readByte() catch throw new case = call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() * return new public public try return call org.apache.lucene.store.RandomAccessInput.readShort(long) call org.apache.lucene.store.RandomAccessInput.readShort(long) call org.apache.lucene.store.RandomAccessInput.readShort(long) call org.apache.lucene.store.RandomAccessInput.readShort(long) call org.apache.lucene.store.RandomAccessInput.readShort(long) long << catch throw new case = call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() * return new public public try return call org.apache.lucene.store.RandomAccessInput.readInt(long) call org.apache.lucene.store.RandomAccessInput.readInt(long) call org.apache.lucene.store.RandomAccessInput.readInt(long) call org.apache.lucene.store.RandomAccessInput.readInt(long) call org.apache.lucene.store.RandomAccessInput.readInt(long) long << catch throw new case = call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() call IndexInput.randomAccessSlice() * return new public public try return call org.apache.lucene.store.RandomAccessInput.readLong(long) call org.apache.lucene.store.RandomAccessInput.readLong(long) call org.apache.lucene.store.RandomAccessInput.readLong(long) call org.apache.lucene.store.RandomAccessInput.readLong(long) call org.apache.lucene.store.RandomAccessInput.readLong(long) long << catch throw new default: throw new public public return public public try return catch throw new public public try return long << catch throw new public public try return long << catch throw new public public try return long << catch throw new public public throws call IndexInput.close() call IndexInput.close() call IndexInput.close() call IndexInput.close() call IndexInput.close() public public return * call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() public public throws public public return + + call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() call decl Map.size() +