org.apache.lucene.index java.io.IOException import java.util.LinkedList import java.util.Queue import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.locks.ReentrantLock import org.apache.lucene.index.DocumentsWriterPerThread.FlushedSegment import class org.apache.lucene.index.DocumentsWriterFlushQueue decl Queue ReentrantLock AtomicInteger boolean throws synchronized decl_stmt boolean = try call decl Queue.add() call decl Queue.add() call decl Queue.add() call decl Queue.add() call decl Queue.add() new = finally if ! int private private decl_stmt int = call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() assert > int private private decl_stmt int = call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() assert >= SegmentFlushTicket boolean synchronized synchronized decl_stmt boolean = try decl_stmt SegmentFlushTicket final final = new call decl Queue.add() call decl Queue.add() call decl Queue.add() call decl Queue.add() call decl Queue.add() = return finally if ! synchronized synchronized synchronized synchronized assert call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() >= : + call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() return call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() != boolean int FlushTicket FlushTicket private private throws assert call java.util.concurrent.locks.ReentrantLock.isHeldByCurrentThread() call java.util.concurrent.locks.ReentrantLock.isHeldByCurrentThread() call java.util.concurrent.locks.ReentrantLock.isHeldByCurrentThread() call java.util.concurrent.locks.ReentrantLock.isHeldByCurrentThread() call java.util.concurrent.locks.ReentrantLock.isHeldByCurrentThread() decl_stmt int = while decl_stmt FlushTicket final final decl_stmt boolean final final synchronized = call decl Queue.peek() call decl Queue.peek() call decl Queue.peek() call decl Queue.peek() call decl Queue.peek() = != && call FlushTicket.canPublish() call FlushTicket.canPublish() call FlushTicket.canPublish() call FlushTicket.canPublish() call FlushTicket.canPublish() if ++ try call FlushTicket.publish() call FlushTicket.publish() call FlushTicket.publish() call FlushTicket.publish() call FlushTicket.publish() finally synchronized decl_stmt FlushTicket final final = call decl Queue.poll() call decl Queue.poll() call decl Queue.poll() call decl Queue.poll() call decl Queue.poll() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() call java.util.concurrent.atomic.AtomicInteger.decrementAndGet() assert == else break return throws assert ! assert ! call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() call java.util.concurrent.locks.ReentrantLock.lock() try return finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() throws assert ! assert ! if call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() call java.util.concurrent.locks.ReentrantLock.tryLock() try return finally call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() call java.util.concurrent.locks.ReentrantLock.unlock() return public public return call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() call java.util.concurrent.atomic.AtomicInteger.get() synchronized synchronized call decl Queue.clear() call decl Queue.clear() call decl Queue.clear() call decl Queue.clear() call decl Queue.clear() call java.util.concurrent.atomic.AtomicInteger.set(int) call java.util.concurrent.atomic.AtomicInteger.set(int) call java.util.concurrent.atomic.AtomicInteger.set(int) call java.util.concurrent.atomic.AtomicInteger.set(int) call java.util.concurrent.atomic.AtomicInteger.set(int) FrozenBufferedUpdates protected final protected final throws assert != assert != decl_stmt org.apache.lucene.index.FrozenBufferedUpdates final final = if + if != && + protected final protected final throws if == assert != if != && if + else protected protected throws assert ! : = protected protected return protected protected throws assert ! : = protected protected assert ! = protected protected assert == = protected protected return != ||