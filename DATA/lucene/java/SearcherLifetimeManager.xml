org.apache.lucene.search java.io.Closeable import java.io.IOException import java.util.ArrayList import java.util.Collections import java.util.List import java.util.concurrent.ConcurrentHashMap import org.apache.lucene.index.DirectoryReader import org.apache.lucene.store.AlreadyClosedException import org.apache.lucene.util.IOUtils import class org.apache.lucene.search.SearcherLifetimeManager super super implements decl ConcurrentHashMap double boolean public public return public synchronized public synchronized throws private private if throw new long SearcherTracker public public throws decl_stmt long final final = decl_stmt SearcherTracker = call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() if == = new if call decl ConcurrentHashMap.putIfAbsent() call decl ConcurrentHashMap.putIfAbsent() call decl ConcurrentHashMap.putIfAbsent() call decl ConcurrentHashMap.putIfAbsent() call decl ConcurrentHashMap.putIfAbsent() != call SearcherTracker.close() call SearcherTracker.close() call SearcherTracker.close() call SearcherTracker.close() call SearcherTracker.close() else if != throw new + + + return SearcherTracker public public decl_stmt SearcherTracker final final = call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() call decl ConcurrentHashMap.get() if != && call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() call SearcherTracker.searcher() return return public public throws public public return > double double double decl List public synchronized public synchronized throws decl_stmt java.util.List final final final < = new <> for : call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() decl_stmt double = decl_stmt double final final = / for : decl_stmt double final final if == = else = - if call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() = decl List public synchronized public synchronized throws = decl_stmt java.util.List final final final < = new <> call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() call decl ConcurrentHashMap.values() for : call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() call decl ConcurrentHashMap.remove() if call decl ConcurrentHashMap.size() call decl ConcurrentHashMap.size() call decl ConcurrentHashMap.size() call decl ConcurrentHashMap.size() call decl ConcurrentHashMap.size() != throw new