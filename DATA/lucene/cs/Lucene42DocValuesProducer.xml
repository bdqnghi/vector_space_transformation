Lucene.Net.Codecs.Lucene42 Lucene.Net.Store using System using System.Collections.Generic using Lucene.Net.Support using Lucene.Net.Util.Fst using Lucene.Net.Index.BinaryDocValues Lucene.Net.Util.Bits Lucene.Net.Util.Packed.BlockPackedReader Lucene.Net.Store.ByteArrayDataInput Lucene.Net.Util.BytesRef Lucene.Net.Store.ChecksumIndexInput Lucene.Net.Index.CorruptIndexException Lucene.Net.Index.DocsAndPositionsEnum Lucene.Net.Index.DocsEnum Lucene.Net.Index.DocValues Lucene.Net.Index.FieldInfo Lucene.Net.Index.FieldInfos Lucene.Net.Index.IndexFileNames Lucene.Net.Store.IndexInput Lucene.Net.Util.IntsRef Lucene.Net.Util.IOUtils Lucene.Net.Util.Packed.MonotonicBlockPackedReader Lucene.Net.Index.NumericDocValues Lucene.Net.Util.Packed.PackedInts Lucene.Net.Util.PagedBytes Lucene.Net.Util.Fst.PositiveIntOutputs Lucene.Net.Util.RamUsageEstimator Lucene.Net.Index.SegmentReadState Lucene.Net.Index.SortedDocValues Lucene.Net.Index.SortedSetDocValues Lucene.Net.Index.TermsEnum Lucene.Net.Util.Fst.Util class Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer super super DocValuesProducer decl IDictionary int int sbyte AtomicLong int sbyte decl IDictionary sbyte decl IDictionary decl IDictionary IndexInput sbyte sbyte decl IDictionary sbyte sbyte int decl IDictionary int int int FSTEntry int int private private decl_stmt int = while != - if < throw new + + + decl_stmt int = if == decl_stmt var = new = = sbyte switch case case case case break default: throw new + + + if != = = else if == decl_stmt BinaryEntry = new = = = = if != = = = else if == decl_stmt FSTEntry = new = = = else throw new + + + = NumericDocValues public override public override lock decl_stmt NumericDocValues call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out if == = = return public override public override return call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() public override public override if >= int decl PackedInts decl byte decl Reader var int var int int long NumericEntry long int private private decl_stmt NumericEntry = call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() switch case decl_stmt int = call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() if > throw new + decl_stmt var = new for = < ++ = call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() decl_stmt int = call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() decl_stmt int = call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() decl_stmt Reader = call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() + call decl PackedInts.RamBytesUsed() call decl PackedInts.RamBytesUsed() call decl PackedInts.RamBytesUsed() call decl PackedInts.RamBytesUsed() call decl PackedInts.RamBytesUsed() return new case decl_stmt int = call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() decl_stmt var = new call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() return case decl_stmt byte = new call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() return new case decl_stmt long = call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() decl_stmt long = call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() call IndexInput.ReadLong() decl_stmt int = call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() call IndexInput.ReadVInt() decl_stmt Lucene.Net.Util.Packed.BlockPackedReader = new call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() return new default: throw new public override public override return int public override public override return sbyte public override public override return + * BinaryDocValues public override public override lock decl_stmt BinaryDocValues if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out = = return BinaryEntry int PagedBytes decl Reader decl PagedBytes private private decl_stmt BinaryEntry = call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() decl_stmt Lucene.Net.Util.PagedBytes = new call Lucene.Net.Util.PagedBytes.Copy(IndexInput,long) call Lucene.Net.Util.PagedBytes.Copy(IndexInput,long) call Lucene.Net.Util.PagedBytes.Copy(IndexInput,long) call Lucene.Net.Util.PagedBytes.Copy(IndexInput,long) call Lucene.Net.Util.PagedBytes.Copy(IndexInput,long) decl_stmt Reader = call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) if == decl_stmt int = call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() return new else decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader = new call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() call Lucene.Net.Util.PagedBytes.RamBytesUsed() + call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() call int.RamBytesUsed() return new public override public override * long long long public override public override decl_stmt long = == : - decl_stmt long = - var var decl FST var var var FSTEntry var var public override public override decl_stmt FSTEntry = decl_stmt Lucene.Net.Util.Fst.FST < ? lock if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() = new < ? call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call decl FST.SizeInBytes() call decl FST.SizeInBytes() call decl FST.SizeInBytes() call decl FST.SizeInBytes() call decl FST.SizeInBytes() = decl_stmt var = decl_stmt var = decl_stmt var = decl_stmt var = new < ? < ? < ? < ? decl_stmt var = new < ? < ? < ? < ? decl_stmt var = new decl_stmt var = new < ? return new public override public override return int IntsRef public override public override try = decl_stmt Lucene.Net.Util.IntsRef = = new = = catch throw public override public override try if == return - - else if return int else return int - - catch throw return int public override public override return new var var var decl FST decl FST var var BinaryDocValues FSTEntry var var public override public override decl_stmt FSTEntry = if == return decl_stmt Lucene.Net.Util.Fst.FST < ? lock if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() = new < ? call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call decl FST.SizeInBytes() call decl FST.SizeInBytes() call decl FST.SizeInBytes() call decl FST.SizeInBytes() call decl FST.SizeInBytes() = decl_stmt BinaryDocValues = decl_stmt Lucene.Net.Util.Fst.FST < ? = decl_stmt var = decl_stmt var = new < ? < ? < ? < ? decl_stmt var = new < ? < ? < ? < ? decl_stmt var = new decl_stmt var = new < ? decl_stmt var = new decl_stmt var = new return new public override public override if return else += return = IntsRef public override public override try = decl_stmt Lucene.Net.Util.IntsRef = = new = = catch throw new var public override public override try decl_stmt var = if == return - - else if call var.Input() call var.Input() call var.Input() call var.Input() call var.Input() call var.Input() call var.Input() call var.Input() call var.Input() return int else return - - catch throw new return public override public override return new public override public override if == return else return new protected override protected override if call IndexInput.Dispose() call IndexInput.Dispose() call IndexInput.Dispose() call IndexInput.Dispose() call IndexInput.Dispose() var public override public override decl_stmt var = if == return else return return public override public override if == return else if return else return public override public override if == return else return IntsRef public override public override = decl_stmt Lucene.Net.Util.IntsRef = = new = = public override public override return public override public override return public override public override throw new public override public override throw new public override public override throw new public override public override throw new