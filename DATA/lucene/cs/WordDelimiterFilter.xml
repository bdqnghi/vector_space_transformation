Lucene.Net.Analysis.Miscellaneous System using System.Text using Lucene.Net.Analysis.Core using Lucene.Net.Analysis.Standard using Lucene.Net.Analysis.Tokenattributes using Lucene.Net.Analysis.Util using Lucene.Net.Support using Lucene.Net.Util using org.apache.lucene.analysis.miscellaneous using class Lucene.Net.Analysis.Miscellaneous.WordDelimiterFilter super super TokenFilter WordDelimiterConcatenation int WordDelimiterIterator decl AttributeSource int int int decl int int int int decl int decl State string int int CharArraySet int bool int int bool int ITypeAttribute int int WordDelimiterConcatenation int int ICharTermAttribute int IOffsetAttribute int bool decl char bool int IPositionIncrementAttribute bool bool int int private private = new = new = new int int decl char public override public override while if ! if ! return decl_stmt int = decl_stmt char = call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Buffer() call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Buffer() call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Buffer() call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Buffer() call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.Buffer() += call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.setText(char,int) call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.setText(char,int) call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.setText(char,int) call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.setText(char,int) call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.setText(char,int) call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() if == && == || != && call Lucene.Net.Analysis.CharArraySet.Contains(string) call Lucene.Net.Analysis.CharArraySet.Contains(string) call Lucene.Net.Analysis.CharArraySet.Contains(string) call Lucene.Net.Analysis.CharArraySet.Contains(string) call Lucene.Net.Analysis.CharArraySet.Contains(string) = = = return if == && ! if == && ! -- continue = = ! = if = = = return if == if ! if continue if ! if > call WordDelimiterConcatenation.writeAndClear() call WordDelimiterConcatenation.writeAndClear() call WordDelimiterConcatenation.writeAndClear() call WordDelimiterConcatenation.writeAndClear() call WordDelimiterConcatenation.writeAndClear() continue call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() if < if == call bool.Sort() call bool.Sort() call bool.Sort() call bool.Sort() call bool.Sort() ++ if && == = = return = = = continue if call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() = return decl_stmt int = call WordDelimiterIterator.type() call WordDelimiterIterator.type() call WordDelimiterIterator.type() call WordDelimiterIterator.type() call WordDelimiterIterator.type() if ! && & == if = continue = if if = if if call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() call Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator.next() public override public override = call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() call WordDelimiterConcatenation.clear() = = = = int protected override protected override decl_stmt int = if == = return decl AttributeSource decl State protected internal override protected internal override decl_stmt Lucene.Net.Util.Automaton.State = = = decl_stmt int = = = = = = int private private if == decl_stmt int = + = = = = call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() = = ++ private private = call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() call IOffsetAttribute.StartOffset() = call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.EndOffset() call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.EndOffset() call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.EndOffset() call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.EndOffset() call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.EndOffset() = - != call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() = call ITypeAttribute.type() call ITypeAttribute.type() call ITypeAttribute.type() call ITypeAttribute.type() call ITypeAttribute.type() if < call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() = new call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.buffer() call ICharTermAttribute.buffer() call ICharTermAttribute.buffer() call ICharTermAttribute.buffer() call ICharTermAttribute.buffer() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() call ICharTermAttribute.length() = = private private = if != || ! return return private private return && || && private private return && || && private private if = + - = + int int private private call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.CopyBuffer(char,int,int) call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.CopyBuffer(char,int,int) call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.CopyBuffer(char,int,int) call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.CopyBuffer(char,int,int) call Lucene.Net.Analysis.Tokenattributes.ICharTermAttribute.CopyBuffer(char,int,int) - decl_stmt int = + decl_stmt int = + if if && <= call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) else call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) else call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) call Lucene.Net.Analysis.Tokenattributes.IOffsetAttribute.SetOffset(int,int) = = int private private decl_stmt int = if = return : = if ! = return = return internal static internal static return & != internal static internal static return & != internal static internal static return & != internal static internal static return & != private private return & != internal internal ++ decl char internal internal if < decl_stmt char = = if else = = = return == internal internal = = = = = internal internal