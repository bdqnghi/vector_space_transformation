Lucene.Net.Analysis.Util System using System.Collections using System.Collections.Generic using System.Threading using class decl IDictionary decl string Type decl LinkedHashMap string string Type decl SPIClassIterator public public lock decl_stmt LinkedHashMap < = new < decl_stmt Lucene.Net.Util.SPIClassIterator < = while call decl SPIClassIterator.hasNext() call decl SPIClassIterator.hasNext() call decl SPIClassIterator.hasNext() call decl SPIClassIterator.hasNext() call decl SPIClassIterator.hasNext() decl_stmt System.Type = call decl SPIClassIterator.next() call decl SPIClassIterator.next() call decl SPIClassIterator.next() call decl SPIClassIterator.next() call decl SPIClassIterator.next() decl_stmt string = decl_stmt string = foreach in if call string.EndsWith() call string.EndsWith() call string.EndsWith() call string.EndsWith() call string.EndsWith() = call string.Substring() call string.Substring() call string.Substring() call string.Substring() call string.Substring() - break if == throw new + + + if ! call decl LinkedHashMap.containsKey() call decl LinkedHashMap.containsKey() call decl LinkedHashMap.containsKey() call decl LinkedHashMap.containsKey() call decl LinkedHashMap.containsKey() call decl LinkedHashMap.put() call decl LinkedHashMap.put() call decl LinkedHashMap.put() call decl LinkedHashMap.put() call decl LinkedHashMap.put() = Type public public < decl_stmt System.Type = try return call Type.getConstructor() call Type.getConstructor() call Type.getConstructor() call Type.getConstructor() call Type.getConstructor() typeof catch throw new + + + + + + + Type public public decl_stmt System.Type = if != return else throw new + + + + + + + public < public < return