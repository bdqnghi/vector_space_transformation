org.apache.lucene.index System using System.Diagnostics using System.Collections.Generic using org.apache.lucene.index.IndexWriterConfig.OpenMode org.apache.lucene.store.Directory org.apache.lucene.store.FSDirectory org.apache.lucene.util.FixedBitSet org.apache.lucene.util.Bits org.apache.lucene.util.Version class org.apache.lucene.index.MultiPassIndexSplitter int int int int int IndexWriter decl IList FakeDeleteIndexReader public virtual public virtual if == || < throw new if == || < throw new decl_stmt int = decl_stmt FakeDeleteIndexReader = new decl_stmt int = call FakeDeleteIndexReader.maxDoc() call FakeDeleteIndexReader.maxDoc() call FakeDeleteIndexReader.maxDoc() call FakeDeleteIndexReader.maxDoc() call FakeDeleteIndexReader.maxDoc() decl_stmt int = / for = < ++ call FakeDeleteIndexReader.undeleteAll() call FakeDeleteIndexReader.undeleteAll() call FakeDeleteIndexReader.undeleteAll() call FakeDeleteIndexReader.undeleteAll() call FakeDeleteIndexReader.undeleteAll() if decl_stmt int = * decl_stmt int = + for = < ++ call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() if < - for = < ++ call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() else for = < ++ if + - != call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() call FakeDeleteIndexReader.deleteDocument() decl_stmt Lucene.Net.Index.IndexWriter = new new + + + decl_stmt System.Collections.Generic.IList < = call IndexWriter.addIndexes() call IndexWriter.addIndexes() call IndexWriter.addIndexes() call IndexWriter.addIndexes() call IndexWriter.addIndexes() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call IndexWriter.close() call IndexWriter.close() call IndexWriter.close() call IndexWriter.close() call IndexWriter.close() decl Directory MultiPassIndexSplitter bool int decl List File File IndexReader Directory string public static public static if < - decl_stmt System.Collections.Generic.List < = new < decl_stmt string = decl_stmt int = - decl_stmt bool = for = < ++ if = ++ else if = ++ else if = else decl_stmt System.IO.File = new if ! call File.exists() call File.exists() call File.exists() call File.exists() call File.exists() || ! + continue decl_stmt Lucene.Net.Store.Directory = new try if ! + continue catch + continue call decl List.Add() call decl List.Add() call decl List.Add() call decl List.Add() call decl List.Add() if == throw new if < throw new if == throw new decl_stmt System.IO.File = new if ! call File.mkdirs() call File.mkdirs() call File.mkdirs() call File.mkdirs() call File.mkdirs() throw new + decl_stmt Lucene.Net.Store.Directory = new for = < ++ = new + decl_stmt org.apache.lucene.index.MultiPassIndexSplitter = new decl_stmt Lucene.Net.Index.IndexReader if == = else = new call decl List.ToArray() call decl List.ToArray() call decl List.ToArray() call decl List.ToArray() call decl List.ToArray() call MultiPassIndexSplitter.Split() call MultiPassIndexSplitter.Split() call MultiPassIndexSplitter.Split() call MultiPassIndexSplitter.Split() call MultiPassIndexSplitter.Split() int decl IList decl FakeDeleteAtomicIndexReader internal static internal static decl_stmt System.Collections.Generic.IList < = decl_stmt FakeDeleteAtomicIndexReader = new decl_stmt int = foreach in ++ = new return int public public decl_stmt int = - public public foreach in protected internal override protected internal override public override public override return Bits int public public decl_stmt int = = new if decl_stmt Lucene.Net.Spatial.Util.Bits = != for = < ++ if call Bits.get() call Bits.get() call Bits.get() call Bits.get() call Bits.get() else public public return