Lucene.Net.Store System.Collections.Concurrent using NUnit.Framework using System using System.Collections.Generic using System.Diagnostics using System.Linq using System.Threading using Lucene.Net.Randomized.Generators using Lucene.Net.Support using System.IO using Lucene.Net.Index.DirectoryReader Lucene.Net.Index.IndexWriter Lucene.Net.Index.IndexWriterConfig Lucene.Net.Util.LuceneTestCase Lucene.Net.Index.NoDeletionPolicy Lucene.Net.Index.SegmentInfos Lucene.Net.Util.TestUtil Lucene.Net.Util.ThrottledIndexOutput class Lucene.Net.Store.MockDirectoryWrapper super super BaseDirectoryWrapper bool decl IDictionary decl ISet Throttling_e double bool decl ConcurrentDictionary decl List AtomicLong bool decl ISet bool long Random decl ISet ThrottledIndexOutput LockFactory bool bool decl ISet decl ISet long bool double bool bool private private lock if == = new < = new < if == = new < if == = new < return int call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() = = = = = = return return = return = return = return = return lock return new < = IndexOutput RAMDirectory IndexOutput RAMFile RAMFile public override public override lock if if throw new lock if && call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() && ! throw new + + if || && call decl IDictionary.ContainsKey() call decl IDictionary.ContainsKey() call decl IDictionary.ContainsKey() call decl IDictionary.ContainsKey() call decl IDictionary.ContainsKey() if ! throw new + + else throw new + + if throw new call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() if is decl_stmt Lucene.Net.Store.RAMDirectory = decl_stmt Lucene.Net.Store.RAMFile = new decl_stmt Lucene.Net.Store.RAMFile = call Lucene.Net.Store.RAMDirectory.GetNameFromFileMap_Nunit(string) call Lucene.Net.Store.RAMDirectory.GetNameFromFileMap_Nunit(string) call Lucene.Net.Store.RAMDirectory.GetNameFromFileMap_Nunit(string) call Lucene.Net.Store.RAMDirectory.GetNameFromFileMap_Nunit(string) call Lucene.Net.Store.RAMDirectory.GetNameFromFileMap_Nunit(string) if != && ! && throw new + + else if != call Lucene.Net.Store.RAMDirectory.GetAndAddSizeInBytes_Nunit(long) call Lucene.Net.Store.RAMDirectory.GetAndAddSizeInBytes_Nunit(long) call Lucene.Net.Store.RAMDirectory.GetAndAddSizeInBytes_Nunit(long) call Lucene.Net.Store.RAMDirectory.GetAndAddSizeInBytes_Nunit(long) call Lucene.Net.Store.RAMDirectory.GetAndAddSizeInBytes_Nunit(long) - call Lucene.Net.Store.RAMFile.SetDirectory_Nunit(RAMDirectory) call Lucene.Net.Store.RAMFile.SetDirectory_Nunit(RAMDirectory) call Lucene.Net.Store.RAMFile.SetDirectory_Nunit(RAMDirectory) call Lucene.Net.Store.RAMFile.SetDirectory_Nunit(RAMDirectory) call Lucene.Net.Store.RAMFile.SetDirectory_Nunit(RAMDirectory) call Lucene.Net.Store.RAMDirectory.SetNameForFileMap_Nunit(string,RAMFile) call Lucene.Net.Store.RAMDirectory.SetNameForFileMap_Nunit(string,RAMFile) call Lucene.Net.Store.RAMDirectory.SetNameForFileMap_Nunit(string,RAMFile) call Lucene.Net.Store.RAMDirectory.SetNameForFileMap_Nunit(string,RAMFile) call Lucene.Net.Store.RAMDirectory.SetNameForFileMap_Nunit(string,RAMFile) decl_stmt IndexOutput = if call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) == = new + call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) decl_stmt IndexOutput = new call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() if == || == && call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) == && ! is if + + return call Lucene.Net.Util.ThrottledIndexOutput.NewFromDelegate(IndexOutput) call Lucene.Net.Util.ThrottledIndexOutput.NewFromDelegate(IndexOutput) call Lucene.Net.Util.ThrottledIndexOutput.NewFromDelegate(IndexOutput) call Lucene.Net.Util.ThrottledIndexOutput.NewFromDelegate(IndexOutput) call Lucene.Net.Util.ThrottledIndexOutput.NewFromDelegate(IndexOutput) else return = IndexInput int IndexInput public override public override lock if if ! throw new + + if ! && call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() && ! throw new + + decl_stmt Lucene.Net.Store.IndexInput = decl_stmt Lucene.Net.Store.IndexInput decl_stmt int = call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) call System.Random.Next(int,int) if == if + = new else if == if + = new else = new return long lock if ! is return decl_stmt long = foreach in += return long lock if ! is return decl_stmt long = foreach in += return = = SegmentInfos decl ISet IndexWriterConfig decl ISet decl HashSet decl string DirectoryReader DirectoryReader int int decl string decl ISet decl IEnumerator decl ISet decl IList Exception decl IList string public override public override lock decl_stmt System.Collections.Generic.ISet < = new < if == = new < = new < if > decl_stmt System.Exception = decl_stmt System.Collections.Generic.IEnumerator < = call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() call decl ConcurrentDictionary.Values() if call decl IEnumerator.MoveNext() call decl IEnumerator.MoveNext() call decl IEnumerator.MoveNext() call decl IEnumerator.MoveNext() call decl IEnumerator.MoveNext() = throw new + call decl IDictionary.ToArray() call decl IDictionary.ToArray() call decl IDictionary.ToArray() call decl IDictionary.ToArray() call decl IDictionary.ToArray() if > throw new + call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() = if = = if if if if decl_stmt System.Collections.Generic.HashSet < = new < call decl HashSet.RemoveAll() call decl HashSet.RemoveAll() call decl HashSet.RemoveAll() call decl HashSet.RemoveAll() call decl HashSet.RemoveAll() decl_stmt string = call decl HashSet.ToArray() call decl HashSet.ToArray() call decl HashSet.ToArray() call decl HashSet.ToArray() call decl HashSet.ToArray() decl_stmt Lucene.Net.Index.IndexWriterConfig = new call Lucene.Net.Index.IndexWriterConfig.SetIndexDeletionPolicy(IndexDeletionPolicy) call Lucene.Net.Index.IndexWriterConfig.SetIndexDeletionPolicy(IndexDeletionPolicy) call Lucene.Net.Index.IndexWriterConfig.SetIndexDeletionPolicy(IndexDeletionPolicy) call Lucene.Net.Index.IndexWriterConfig.SetIndexDeletionPolicy(IndexDeletionPolicy) call Lucene.Net.Index.IndexWriterConfig.SetIndexDeletionPolicy(IndexDeletionPolicy) new decl_stmt string = decl_stmt System.Collections.Generic.ISet < = new < decl_stmt System.Collections.Generic.ISet < = new < if call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() && call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() if foreach in if && ! && call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() if + + decl_stmt Lucene.Net.Index.SegmentInfos = new try call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) catch try decl_stmt System.Collections.Generic.ISet < = new < call Lucene.Net.Index.SegmentInfos.Files(Directory,bool) call Lucene.Net.Index.SegmentInfos.Files(Directory,bool) call Lucene.Net.Index.SegmentInfos.Files(Directory,bool) call Lucene.Net.Index.SegmentInfos.Files(Directory,bool) call Lucene.Net.Index.SegmentInfos.Files(Directory,bool) foreach in if call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() && ! call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() if + + + + + call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() call decl ISet.Add() catch + + = call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() = call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() call decl ISet.ToArray() if ! decl_stmt System.Collections.Generic.IList < = new < foreach in if ! call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() decl_stmt System.Collections.Generic.IList < = new < foreach in if ! call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() decl_stmt string if != = + else = if != += + if != += + + + + + decl_stmt Lucene.Net.Index.DirectoryReader = decl_stmt int = call DirectoryReader.Dispose() call DirectoryReader.Dispose() call DirectoryReader.Dispose() call DirectoryReader.Dispose() call DirectoryReader.Dispose() new new decl_stmt Lucene.Net.Index.DirectoryReader = decl_stmt int = call DirectoryReader.Dispose() call DirectoryReader.Dispose() call DirectoryReader.Dispose() call DirectoryReader.Dispose() call DirectoryReader.Dispose() == + + + Exception int internal virtual internal virtual lock decl_stmt int if call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out if == call decl IDictionary.Remove() call decl IDictionary.Remove() call decl IDictionary.Remove() call decl IDictionary.Remove() call decl IDictionary.Remove() decl_stmt System.Exception call decl ConcurrentDictionary.TryRemove() call decl ConcurrentDictionary.TryRemove() call decl ConcurrentDictionary.TryRemove() call decl ConcurrentDictionary.TryRemove() call decl ConcurrentDictionary.TryRemove() out else -- = public virtual public virtual lock call decl ISet.Remove() call decl ISet.Remove() call decl ISet.Remove() call decl ISet.Remove() call decl ISet.Remove() public virtual public virtual lock public virtual public virtual public virtual public virtual return public virtual public virtual = public virtual public virtual = public virtual public virtual lock if == = new < call decl List.Add() call decl List.Add() call decl List.Add() call decl List.Add() call decl List.Add() internal virtual internal virtual lock if != for = < ++ public override public override lock return public override public override lock return public override public override lock return public override public override lock return public override public override lock lock = = new lock if return else return lock return public override public override lock IndexInputSlicer IndexInputSlicer public override public override if ! throw call Random.NextBoolean() call Random.NextBoolean() call Random.NextBoolean() call Random.NextBoolean() call Random.NextBoolean() new : new if call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() call decl ISet.Contains() && ! throw new + + decl_stmt IndexInputSlicer = decl_stmt IndexInputSlicer = new return public override public override if == ref if IndexInput public override public override decl_stmt Lucene.Net.Store.IndexInput = new return IndexInput public override public override decl_stmt Lucene.Net.Store.IndexInput = new return return protected override protected override public override public override public override public override try finally public override public override try finally