Lucene.Net.Search System using System.Collections.Concurrent using System.Collections.Generic using System.Diagnostics using Lucene.Net.Support using Lucene.Net.Store.Directory Lucene.Net.Index.IndexReader Lucene.Net.Index.IndexWriter Lucene.Net.Index.IndexWriterConfig Lucene.Net.Util.LineFileDocs Lucene.Net.Util.LuceneTestCase Lucene.Net.Analysis.MockAnalyzer Lucene.Net.Util.PrintStreamInfoStream Lucene.Net.Index.Term Lucene.Net.Index.TermContext Lucene.Net.Util.TestUtil class Lucene.Net.Search.ShardSearchingTestBase super super LuceneTestCase decl string ThreadClass decl NodeState DateTime int public override public override return * + FieldAndShardVersion public override public override if ! is return decl_stmt FieldAndShardVersion = return && == && == public override public override return + + + + + + public override public override return * + TermAndShardVersion public override public override if ! is return decl_stmt TermAndShardVersion = return && == && == CollectionStatistics internal virtual internal virtual if + + + + + foreach in decl_stmt Lucene.Net.Search.CollectionStatistics = foreach in if != new = foreach in decl NodeState internal virtual internal virtual decl_stmt ShardIndexSearcher = try if == if != return call decl NodeState.LocalSearchAfter() call decl NodeState.LocalSearchAfter() call decl NodeState.LocalSearchAfter() call decl NodeState.LocalSearchAfter() call decl NodeState.LocalSearchAfter() else return call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() else == return call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() call decl NodeState.LocalSearch() finally NodeState TermContext IndexSearcher decl IDictionary internal virtual < internal virtual < < decl_stmt NodeState = decl_stmt SpellChecker.Net.Search.Spell.IDictionary < = new < decl_stmt Lucene.Net.Search.IndexSearcher = call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() if == throw new + + + try foreach in decl_stmt Lucene.Net.Index.TermContext = = call Lucene.Net.Search.IndexSearcher.TermStatistics(Term,TermContext) call Lucene.Net.Search.IndexSearcher.TermStatistics(Term,TermContext) call Lucene.Net.Search.IndexSearcher.TermStatistics(Term,TermContext) call Lucene.Net.Search.IndexSearcher.TermStatistics(Term,TermContext) call Lucene.Net.Search.IndexSearcher.TermStatistics(Term,TermContext) finally call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() call NodeState.Searchers() return decl HashSet Query TermAndShardVersion decl HashSet public override public override decl_stmt Lucene.Net.Search.Query = decl_stmt System.Collections.Generic.HashSet < = new < call Lucene.Net.Search.Query.ExtractTerms(ISet) call Lucene.Net.Search.Query.ExtractTerms(ISet) call Lucene.Net.Search.Query.ExtractTerms(ISet) call Lucene.Net.Search.Query.ExtractTerms(ISet) call Lucene.Net.Search.Query.ExtractTerms(ISet) for = < ++ if == continue decl_stmt System.Collections.Generic.HashSet < = new < foreach in decl_stmt TermAndShardVersion = new if ! call decl HashSet.Add() call decl HashSet.Add() call decl HashSet.Add() call decl HashSet.Add() call decl HashSet.Add() if != foreach < in decl_stmt TermAndShardVersion = new = return long long TermStatistics TermAndShardVersion long long public override public override != decl_stmt long = decl_stmt long = for = < ++ decl_stmt Lucene.Net.Search.TermStatistics if == = else decl_stmt TermAndShardVersion = new = != decl_stmt long = call TermStatistics.DocFreq() call TermStatistics.DocFreq() call TermStatistics.DocFreq() call TermStatistics.DocFreq() call TermStatistics.DocFreq() if >= && >= += else = - decl_stmt long = call Lucene.Net.Search.TermStatistics.TotalTermFreq() call Lucene.Net.Search.TermStatistics.TotalTermFreq() call Lucene.Net.Search.TermStatistics.TotalTermFreq() call Lucene.Net.Search.TermStatistics.TotalTermFreq() call Lucene.Net.Search.TermStatistics.TotalTermFreq() if >= && >= += else = - return new long long long long CollectionStatistics FieldAndShardVersion long long long public override public override decl_stmt long = decl_stmt long = decl_stmt long = decl_stmt long = for = < ++ decl_stmt FieldAndShardVersion = new decl_stmt Lucene.Net.Search.CollectionStatistics if == = else = if == + + + != + + + + + + + decl_stmt long = call Lucene.Net.Search.CollectionStatistics.DocCount() call Lucene.Net.Search.CollectionStatistics.DocCount() call Lucene.Net.Search.CollectionStatistics.DocCount() call Lucene.Net.Search.CollectionStatistics.DocCount() call Lucene.Net.Search.CollectionStatistics.DocCount() if >= && >= += else = - decl_stmt long = call Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq() call Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq() call Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq() call Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq() call Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq() if >= && >= += else = - decl_stmt long = call Lucene.Net.Search.CollectionStatistics.SumDocFreq() call Lucene.Net.Search.CollectionStatistics.SumDocFreq() call Lucene.Net.Search.CollectionStatistics.SumDocFreq() call Lucene.Net.Search.CollectionStatistics.SumDocFreq() call Lucene.Net.Search.CollectionStatistics.SumDocFreq() if >= && >= += else = - >= += return new decl TopDocs public override public override decl_stmt Lucene.Net.Search.TopDocs = new for = < ++ if == = else = return public virtual public virtual return decl NodeState ScoreDoc decl TopDocs public override public override decl_stmt Lucene.Net.Search.TopDocs = new decl_stmt Lucene.Net.Search.ScoreDoc = new for = < ++ if < decl_stmt ShardIndexSearcher = try = - finally else if == = else = - if == = else = return public virtual public virtual return decl TopDocs public override public override != decl_stmt Lucene.Net.Search.TopDocs = new for = < ++ if == = else = return public virtual public virtual return public public == = new public public = if != = new ShardIndexSearcher public public while decl_stmt ShardIndexSearcher = if call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() call ShardIndexSearcher.IndexReader() return public public IndexSearcher public public decl_stmt Lucene.Net.Search.IndexSearcher = if == throw new + + + return new IndexSearcher long IndexSearcher public public decl_stmt Lucene.Net.Search.IndexSearcher = decl_stmt Lucene.Net.Search.IndexSearcher = try if != decl_stmt long = new finally public public if != NodeState LineFileDocs int int public override public override try decl_stmt Lucene.Net.Util.LineFileDocs = new decl_stmt int = while < decl_stmt int = decl_stmt NodeState = if == || == call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() ++ else if == call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() new + call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() call Lucene.Net.Util.LineFileDocs.NextDoc() ++ else call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() new + if == call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() call NodeState.Writer() if == catch throw new IndexSearcher decl long protected internal virtual protected internal virtual = = = new for = < ++ = new decl_stmt long = new for = < ++ decl_stmt Lucene.Net.Search.IndexSearcher = try = finally for = < ++ decl_stmt Lucene.Net.Search.IndexSearcher = == != try finally = new call Lucene.Net.Support.ThreadClass.Start() call Lucene.Net.Support.ThreadClass.Start() call Lucene.Net.Support.ThreadClass.Start() call Lucene.Net.Support.ThreadClass.Start() call Lucene.Net.Support.ThreadClass.Start() protected internal virtual protected internal virtual call Lucene.Net.Support.ThreadClass.Join(long,int) call Lucene.Net.Support.ThreadClass.Join(long,int) call Lucene.Net.Support.ThreadClass.Join(long,int) call Lucene.Net.Support.ThreadClass.Join(long,int) call Lucene.Net.Support.ThreadClass.Join(long,int) foreach in