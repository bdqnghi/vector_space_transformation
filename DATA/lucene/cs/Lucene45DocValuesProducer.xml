Lucene.Net.Codecs.Lucene45 Lucene.Net.Util using System using System.Collections.Generic using Lucene.Net.Support using Lucene.Net.Index.BinaryDocValues Lucene.Net.Util.Bits Lucene.Net.Util.Packed.BlockPackedReader Lucene.Net.Util.BytesRef Lucene.Net.Store.ChecksumIndexInput Lucene.Net.Index.DocsAndPositionsEnum Lucene.Net.Index.DocsEnum Lucene.Net.Index.DocValues Lucene.Net.Index.FieldInfo Lucene.Net.Index.FieldInfos Lucene.Net.Index.IndexFileNames Lucene.Net.Store.IndexInput Lucene.Net.Util.IOUtils Lucene.Net.Util.LongValues Lucene.Net.Util.Packed.MonotonicBlockPackedReader Lucene.Net.Index.NumericDocValues Lucene.Net.Util.Packed.PackedInts Lucene.Net.Util.RamUsageEstimator Lucene.Net.Index.RandomAccessOrds Lucene.Net.Index.SegmentReadState Lucene.Net.Index.SortedDocValues Lucene.Net.Index.SortedSetDocValues Lucene.Net.Index.TermsEnum class Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer super super DocValuesProducer super IDisposable decl IDictionary int IndexInput decl IDictionary AtomicLong decl IDictionary int decl IDictionary decl IDictionary decl IDictionary decl IDictionary BinaryEntry NumericEntry private private if != throw new + + + + if != throw new + + + + decl_stmt BinaryEntry = = if != throw new + + + + if != throw new + + + + decl_stmt NumericEntry = = NumericEntry NumericEntry BinaryEntry private private if != throw new + + + + if != throw new + + + + decl_stmt BinaryEntry = = if != throw new + + + + if != throw new + + + + decl_stmt NumericEntry = = if != throw new + + + + if != throw new + + + + decl_stmt NumericEntry = = SortedSetEntry byte BinaryEntry int private private decl_stmt int = while != - if < throw new + + + + decl_stmt byte = if == = else if == decl_stmt BinaryEntry = = else if == else if == decl_stmt SortedSetEntry = = if == else if == if != throw new + + + + if != throw new + + + + else throw new else throw new + + + = NumericEntry int internal static internal static decl_stmt NumericEntry = new = = = = = = switch case = = break case if > throw new + decl_stmt int = if > throw new + = new for = < ++ = break case break default: throw new + + + return BinaryEntry internal static internal static decl_stmt BinaryEntry = new = = = = = = switch case break case = = = = break case = = = break default: throw new + + + return SortedSetEntry internal virtual internal virtual decl_stmt SortedSetEntry = new if >= = else = if != && != throw new + + + return NumericEntry public override public override decl_stmt NumericEntry = return public override public override return call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() call Lucene.Net.Support.AtomicLong.Get() public override public override if >= long decl PackedInts int BlockPackedReader BlockPackedReader decl long IndexInput long internal virtual internal virtual decl_stmt Lucene.Net.Store.IndexInput = call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() switch case decl_stmt Lucene.Net.Util.Packed.BlockPackedReader = new return case decl_stmt long = decl_stmt long = decl_stmt Lucene.Net.Util.Packed.BlockPackedReader = new return new case decl_stmt long = decl_stmt int = - decl_stmt Reader = int return new default: throw new public override public override return + * public override public override return int call decl IDictionary.Get() call decl IDictionary.Get() call decl IDictionary.Get() call decl IDictionary.Get() call decl IDictionary.Get() int BinaryEntry public override public override decl_stmt BinaryEntry = switch case return case return case return default: throw new IndexInput private private decl_stmt Lucene.Net.Store.IndexInput = return new var long public override public override decl_stmt long = + * try call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() decl_stmt var = new call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() = = = catch throw MonotonicBlockPackedReader MonotonicBlockPackedReader protected internal virtual protected internal virtual decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader lock decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out = new = call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() + = return IndexInput MonotonicBlockPackedReader private private decl_stmt Lucene.Net.Store.IndexInput = decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader = return new long var int long public override public override decl_stmt long = + == : - decl_stmt long = + decl_stmt int = - try call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() decl_stmt var = new call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() call IndexInput.ReadBytes() = = = catch throw long MonotonicBlockPackedReader MonotonicBlockPackedReader long protected internal virtual protected internal virtual decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader decl_stmt long = lock decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out decl_stmt long if == = / else = + / = new = call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() + = return IndexInput MonotonicBlockPackedReader private private decl_stmt Lucene.Net.Store.IndexInput = decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader = return new BinaryDocValues int IndexInput BlockPackedReader NumericEntry public override public override decl_stmt int = int decl_stmt BinaryDocValues = decl_stmt NumericEntry = decl_stmt Lucene.Net.Store.IndexInput = call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() call IndexInput.Seek() decl_stmt Lucene.Net.Util.Packed.BlockPackedReader = new return new public override public override return int public override public override return public override public override if is return else return public override public override if is return else return MonotonicBlockPackedReader MonotonicBlockPackedReader protected internal virtual protected internal virtual decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader lock decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out = new = call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call AtomicLong.AddAndGet() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() call MonotonicBlockPackedReader.RamBytesUsed() + = return LongBinaryDocValues MonotonicBlockPackedReader SortedSetEntry LongValues long SortedDocValues IndexInput public override public override decl_stmt SortedSetEntry = if == decl_stmt Lucene.Net.Index.SortedDocValues = return else if != throw new decl_stmt Lucene.Net.Store.IndexInput = decl_stmt long = decl_stmt LongBinaryDocValues = decl_stmt Lucene.Net.Util.LongValues = decl_stmt Lucene.Net.Util.Packed.MonotonicBlockPackedReader = return new long public override public override if == return else decl_stmt long = ++ return = = == : - = public override public override return public override public override if is return else return public override public override if is return else return public override public override return + public override public override return - IndexInput private private if == - return new else decl_stmt Lucene.Net.Store.IndexInput = call IndexInput.Clone() call IndexInput.Clone() call IndexInput.Clone() call IndexInput.Clone() call IndexInput.Clone() return new public virtual public virtual try + >> return & << & != catch throw public virtual public virtual return BinaryEntry NumericEntry public override public override switch case return case return case decl_stmt BinaryEntry = return case decl_stmt NumericEntry = return default: throw new protected override protected override if call IndexInput.Dispose() call IndexInput.Dispose() call IndexInput.Dispose() call IndexInput.Dispose() call IndexInput.Dispose() public override sealed public override sealed long BytesRef public override public override try decl_stmt Lucene.Net.Util.BytesRef = = = = catch throw decl TermsEnum internal virtual internal virtual try decl_stmt SeekStatus = if == return - - else if == return else return - - catch throw try return call IndexInput.Clone() call IndexInput.Clone() call IndexInput.Clone() call IndexInput.Clone() call IndexInput.Clone() catch throw internal virtual internal virtual return new public override public override if == return else return int int private private if ++ >= return else decl_stmt int = decl_stmt int = = + return long int long long long public override public override decl_stmt long = decl_stmt long = - while <= decl_stmt long = + >> * decl_stmt int = if < = + else if > = - else return if == return decl_stmt long = - < - : * while != decl_stmt int = if == return else if > return return public override public override long private private decl_stmt long = / if >= && == / else = - - + while < private private = new = public override public override return public override public override return return public override public override throw new public override public override return - public override public override throw new public override public override throw new