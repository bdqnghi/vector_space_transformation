Lucene.Net.Analysis.Miscellaneous System using System.Collections.Generic using Lucene.Net.Analysis.Util using Lucene.Net.Support using Lucene.Net.Util using org.apache.lucene.analysis.miscellaneous using class Lucene.Net.Analysis.Miscellaneous.WordDelimiterFilterFactory super super TokenFilterFactory super ResourceLoaderAware CharArraySet string Pattern string int string decl char decl sbyte string decl IList decl IList decl IList public virtual public virtual if != = if != decl_stmt System.Collections.Generic.IList < = decl_stmt System.Collections.Generic.IList < = new < foreach in decl_stmt System.Collections.Generic.IList < = call decl IList.AddRange() call decl IList.AddRange() call decl IList.AddRange() call decl IList.AddRange() call decl IList.AddRange() = public override public override if return new == : else return new ?? string sbyte Matcher decl SortedMap decl sbyte private private < decl_stmt SortedMap < ? ? = new < ? ? foreach in decl_stmt Matcher = call Pattern.matcher() call Pattern.matcher() call Pattern.matcher() call Pattern.matcher() call Pattern.matcher() if ! call Matcher.find() call Matcher.find() call Matcher.find() call Matcher.find() call Matcher.find() throw new + + decl_stmt string = call Matcher.group() call Matcher.group() call Matcher.group() call Matcher.group() call Matcher.group() decl_stmt sbyte ? = call Matcher.group() call Matcher.group() call Matcher.group() call Matcher.group() call Matcher.group() if != throw new + + if == throw new + + call decl SortedMap.put() call decl SortedMap.put() call decl SortedMap.put() call decl SortedMap.put() call decl SortedMap.put() decl_stmt sbyte = new call decl SortedMap.LastKey() call decl SortedMap.LastKey() call decl SortedMap.LastKey() call decl SortedMap.LastKey() call decl SortedMap.LastKey() + for = < ++ = foreach < ? ? in call decl SortedMap.EntrySet() call decl SortedMap.EntrySet() call decl SortedMap.EntrySet() call decl SortedMap.EntrySet() call decl SortedMap.EntrySet() = return private ? private ? if return else if return else if return else if return else if return else if return else return char int int int private private decl_stmt int = decl_stmt int = decl_stmt int = while < decl_stmt char = ++ if == if >= throw new + + = ++ switch case = break case = break case = break case = break case = break case = break case if + >= throw new + + = char += break ++ = return new