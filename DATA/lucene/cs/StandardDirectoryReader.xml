Lucene.Net.Index System using System.Collections.Generic using System.Diagnostics using System.Linq using System.Text using Lucene.Net.Store.AlreadyClosedException Lucene.Net.Store.Directory Lucene.Net.Store.IOContext Lucene.Net.Util.IOUtils class Lucene.Net.Index.StandardDirectoryReader super super DirectoryReader bool IndexWriter int SegmentInfos internal static internal static return new var decl System decl IO var protected internal override protected internal override decl_stmt var = new call var.Read() call var.Read() call var.Read() call var.Read() call var.Read() decl_stmt var = new call var.Size() call var.Size() call var.Size() call var.Size() call var.Size() for = call var.Size() call var.Size() call var.Size() call var.Size() call var.Size() - >= -- decl_stmt IOException = decl_stmt bool = try = new call var.Info() call var.Info() call var.Info() call var.Info() call var.Info() = catch = finally if ! return new SegmentCommitInfo int SegmentInfos bool decl IList ReadersAndUpdates StandardDirectoryReader SegmentReader int Directory internal static internal static decl_stmt int = decl_stmt System.Collections.Generic.IList < = new < decl_stmt Lucene.Net.Store.Directory = decl_stmt Lucene.Net.Index.SegmentInfos = decl_stmt int = decl_stmt bool = try for = < ++ decl_stmt Lucene.Net.Index.SegmentCommitInfo = == decl_stmt Lucene.Net.Index.ReadersAndUpdates = try decl_stmt Lucene.Net.Index.SegmentReader = call Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(IOContext) call Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(IOContext) call Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(IOContext) call Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(IOContext) call Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(IOContext) if > || call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() ++ else call SegmentReader.DecRef() call SegmentReader.DecRef() call SegmentReader.DecRef() call SegmentReader.DecRef() call SegmentReader.DecRef() call Lucene.Net.Index.SegmentInfos.Remove(int) call Lucene.Net.Index.SegmentInfos.Remove(int) call Lucene.Net.Index.SegmentInfos.Remove(int) call Lucene.Net.Index.SegmentInfos.Remove(int) call Lucene.Net.Index.SegmentInfos.Remove(int) finally decl_stmt Lucene.Net.Index.StandardDirectoryReader = new call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() = return finally if ! foreach in try catch int decl bool bool decl IDictionary SegmentReader SegmentReader Exception decl SegmentReader private static private static < decl_stmt SpellChecker.Net.Search.Spell.IDictionary < ? = new < ? if != for = = < ++ decl_stmt Lucene.Net.Index.SegmentReader = = decl_stmt Lucene.Net.Index.SegmentReader = new decl_stmt bool = new for = - >= -- decl_stmt int ? call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out if == = else = int decl_stmt bool = decl_stmt System.Exception = try decl_stmt Lucene.Net.Index.SegmentReader if == || != = new = = else if == && == = else = == || if == = new else = new = catch = finally if ! for ++ < ++ if != try if ! else catch if == = return new StringBuilder string public override public override decl_stmt System.Text.StringBuilder = new call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) decl_stmt string = if != call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) if != call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) foreach in call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) call System.Text.StringBuilder.Append(byte) return call System.Text.StringBuilder.ToString(int,int) call System.Text.StringBuilder.ToString(int,int) call System.Text.StringBuilder.ToString(int,int) call System.Text.StringBuilder.ToString(int,int) call System.Text.StringBuilder.ToString(int,int) protected internal override protected internal override return protected internal override protected internal override if != return else return protected internal override protected internal override if == && == return else return DirectoryReader private private if != return if call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) return decl_stmt Lucene.Net.Index.DirectoryReader = call Lucene.Net.Index.IndexWriter.GetReader(bool) call Lucene.Net.Index.IndexWriter.GetReader(bool) call Lucene.Net.Index.IndexWriter.GetReader(bool) call Lucene.Net.Index.IndexWriter.GetReader(bool) call Lucene.Net.Index.IndexWriter.GetReader(bool) if == call DirectoryReader.DecRef() call DirectoryReader.DecRef() call DirectoryReader.DecRef() call DirectoryReader.DecRef() call DirectoryReader.DecRef() return return private private if == if return else if != throw new if != && return return private private return new SegmentInfos protected internal override protected internal override decl_stmt Lucene.Net.Index.SegmentInfos = new call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) return internal internal return < return SegmentInfos if == || decl_stmt Lucene.Net.Index.SegmentInfos = new call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) call Lucene.Net.Index.SegmentInfos.Read(Directory) return == else return call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) call Lucene.Net.Index.IndexWriter.NrtIsCurrent(SegmentInfos) Exception protected internal override protected internal override decl_stmt System.Exception = foreach in try catch if == = if != try call Lucene.Net.Index.IndexWriter.DecRefDeleter(SegmentInfos) call Lucene.Net.Index.IndexWriter.DecRefDeleter(SegmentInfos) call Lucene.Net.Index.IndexWriter.DecRefDeleter(SegmentInfos) call Lucene.Net.Index.IndexWriter.DecRefDeleter(SegmentInfos) call Lucene.Net.Index.IndexWriter.DecRefDeleter(SegmentInfos) catch return new public override public override return + + return return return return return return return public override public override throw new