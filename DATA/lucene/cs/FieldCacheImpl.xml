Lucene.Net.Search System using System.Collections.Generic using System.Diagnostics using System.Linq using Lucene.Net.Support using System.IO using Lucene.Net.Index.AtomicReader Lucene.Net.Index.BinaryDocValues Lucene.Net.Util.Bits Lucene.Net.Util.BytesRef Lucene.Net.Index.DocsEnum Lucene.Net.Index.DocTermOrds Lucene.Net.Index.DocValues Lucene.Net.Util.FieldCacheSanityChecker Lucene.Net.Index.FieldInfo Lucene.Net.Util.FixedBitSet Lucene.Net.Util.Packed.GrowableWriter Lucene.Net.Index.IndexReader Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer Lucene.Net.Index.NumericDocValues Lucene.Net.Util.Packed.PackedInts Lucene.Net.Util.PagedBytes Lucene.Net.Index.SegmentReader Lucene.Net.Index.SortedDocValues Lucene.Net.Index.SortedSetDocValues Lucene.Net.Index.Terms Lucene.Net.Index.TermsEnum class Lucene.Net.Search.FieldCacheImpl super super IFieldCache decl CoreClosedListener decl SegmentReader decl IndexReader decl IDictionary private private lock = new < typeof sbyte = new typeof short = new typeof int = new typeof float = new typeof long = new typeof double = new typeof = new typeof = new typeof = new typeof = new public virtual public virtual lock public virtual public virtual lock foreach in Type Cache decl IDictionary decl IList object CacheKey lock decl_stmt System.Collections.Generic.IList < = new < foreach < in decl_stmt Lucene.Net.Util.Cache.Cache = decl_stmt System.Type = lock foreach < < in decl_stmt object = if == continue decl_stmt SpellChecker.Net.Search.Spell.IDictionary < = foreach < in decl_stmt System.Web.Caching.CacheKey = call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() call decl IList.Add() new return call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() call decl IList.ToArray() public public public public is object private private if is else decl_stmt object = if is else public virtual public virtual lock decl IDictionary object public virtual public virtual decl_stmt object = lock decl_stmt SpellChecker.Net.Search.Spell.IDictionary < = if == = new < = if ! call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out = else decl FieldCache decl IDictionary decl CreationPlaceholder object object public virtual public virtual decl_stmt SpellChecker.Net.Search.Spell.IDictionary < decl_stmt object decl_stmt object = lock = if == = new < = = else call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() call decl IDictionary.TryGetValue() out if == = new = if is lock decl_stmt CreationPlaceholder = if == = lock = if != && != decl_stmt System.IO.StreamWriter = if != return return decl FieldCacheSanityChecker decl FieldCacheSanityChecker decl Insanity internal virtual internal virtual decl_stmt Insanity = for = < ++ decl_stmt Insanity = decl_stmt CacheEntry = for = < ++ if == call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() + call decl Insanity.ToString() call decl Insanity.ToString() call decl Insanity.ToString() call decl Insanity.ToString() call decl Insanity.ToString() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() call decl IndexReader.WriteLine() new break CacheKey public override public override if is decl_stmt System.Web.Caching.CacheKey = if call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() call CacheKey.Field() if == if == return else if call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() call CacheKey.Custom() return return public override public override return ^ == : BytesRef Terms int FixedBitSet TermsEnum DocsEnum int int public virtual public virtual decl_stmt int = decl_stmt Lucene.Net.Index.Terms = if != if decl_stmt int = <= if == = new = decl_stmt Lucene.Net.Index.TermsEnum = decl_stmt Lucene.Net.Index.DocsEnum = decl_stmt Lucene.Net.Spatial.Util.FixedBitSet = while decl_stmt Lucene.Net.Util.BytesRef = call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() if == break = call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) while decl_stmt int = call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() if == break if if == = = new call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) Bits int int internal virtual internal virtual decl_stmt int = decl_stmt Lucene.Net.Spatial.Util.Bits if == = new else if is decl_stmt int = if >= == = new else = else = typeof new public virtual public virtual return FieldInfo NumericDocValues public virtual public virtual decl_stmt NumericDocValues = if != return new else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof sbyte new public override public override return sbyte public override public override return decl IByteParser decl FieldCache decl sbyte int protected internal override protected internal override decl_stmt int = decl_stmt sbyte decl_stmt IByteParser = if == return = new decl_stmt Uninvert = new call decl IByteParser.DoUninvert() call decl IByteParser.DoUninvert() call decl IByteParser.DoUninvert() call decl IByteParser.DoUninvert() call decl IByteParser.DoUninvert() if return new protected override protected override = protected override protected override = protected override protected override return public virtual public virtual return FieldInfo NumericDocValues public virtual public virtual decl_stmt NumericDocValues = if != return new else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof short new public override public override return short public override public override return decl IShortParser decl FieldCache decl short int protected internal override protected internal override decl_stmt int = decl_stmt short decl_stmt IShortParser = if == return = new decl_stmt Uninvert = new call decl IShortParser.DoUninvert() call decl IShortParser.DoUninvert() call decl IShortParser.DoUninvert() call decl IShortParser.DoUninvert() call decl IShortParser.DoUninvert() if return new protected override protected override = protected override protected override = protected override protected override return public virtual public virtual return FieldInfo NumericDocValues public virtual public virtual decl_stmt NumericDocValues = if != return new else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof int new public override public override return int long public override public override decl_stmt long = return + int public virtual public virtual = public virtual public virtual return Uninvert decl HoldsOneThing decl FieldCache decl IIntParser protected internal override protected internal override decl_stmt IIntParser = if == try return catch return decl_stmt HoldsOneThing < = new < decl_stmt Uninvert = new call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() if decl_stmt GrowableWriterAndMinValue = call decl IIntParser.Get() call decl IIntParser.Get() call decl IIntParser.Get() call decl IIntParser.Get() call decl IIntParser.Get() if == return new new return new int int protected override protected override = if == decl_stmt int if < = = - & else = = = new if != - & new protected override protected override - & protected override protected override return FieldInfo public virtual public virtual decl_stmt Lucene.Net.Index.FieldInfo = if == return new else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() return else if ! return new return typeof new BytesRef Terms DocsEnum int TermsEnum FixedBitSet string int int int protected internal override protected internal override decl_stmt string = decl_stmt int = decl_stmt Lucene.Net.Spatial.Util.FixedBitSet = decl_stmt Lucene.Net.Index.Terms = if != decl_stmt int = <= if == return new decl_stmt Lucene.Net.Index.TermsEnum = call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() decl_stmt Lucene.Net.Index.DocsEnum = while decl_stmt Lucene.Net.Util.BytesRef = call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() if == break if == = new = call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) while decl_stmt int = call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() if == break call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) call Lucene.Net.Spatial.Util.FixedBitSet.Set(int) if == return new decl_stmt int = call Lucene.Net.Spatial.Util.FixedBitSet.Cardinality() call Lucene.Net.Spatial.Util.FixedBitSet.Cardinality() call Lucene.Net.Spatial.Util.FixedBitSet.Cardinality() call Lucene.Net.Spatial.Util.FixedBitSet.Cardinality() call Lucene.Net.Spatial.Util.FixedBitSet.Cardinality() if >= == return new return public virtual public virtual return FieldInfo NumericDocValues public virtual public virtual decl_stmt NumericDocValues = if != return new else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof float new public override public override return int public override public override return Uninvert decl HoldsOneThing decl FieldCache decl IFloatParser protected internal override protected internal override decl_stmt IFloatParser = if == try return catch return decl_stmt HoldsOneThing < = new < decl_stmt Uninvert = new call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() if decl_stmt float = call decl IFloatParser.Get() call decl IFloatParser.Get() call decl IFloatParser.Get() call decl IFloatParser.Get() call decl IFloatParser.Get() if == = new return new protected override protected override = if == = new protected override protected override = protected override protected override return public virtual public virtual return FieldInfo NumericDocValues public virtual public virtual decl_stmt NumericDocValues = if != return new else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof long new public override public override return public override public override return + Uninvert decl HoldsOneThing decl FieldCache decl ILongParser protected internal override protected internal override decl_stmt ILongParser = if == try return catch return decl_stmt HoldsOneThing < = new < decl_stmt Uninvert = new call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() if decl_stmt GrowableWriterAndMinValue = call decl ILongParser.Get() call decl ILongParser.Get() call decl ILongParser.Get() call decl ILongParser.Get() call decl ILongParser.Get() if == return new new return new int protected override protected override = if == decl_stmt int if < = = == : - else = = = new if != - new protected override protected override - protected override protected override return public virtual public virtual return FieldInfo NumericDocValues public virtual public virtual decl_stmt NumericDocValues = if != return new else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof double new public override public override return public override public override return Uninvert decl HoldsOneThing decl FieldCache decl IDoubleParser protected internal override protected internal override decl_stmt IDoubleParser = if == try return catch return decl_stmt HoldsOneThing < = new < decl_stmt Uninvert = new call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() call decl HoldsOneThing.DoUninvert() if decl_stmt double = call decl IDoubleParser.Get() call decl IDoubleParser.Get() call decl IDoubleParser.Get() call decl IDoubleParser.Get() call decl IDoubleParser.Get() if == = new return new protected override protected override = if == = new protected override protected override = protected override protected override return return public override public override return int - public override public override if < throw new + + public virtual public virtual return FieldInfo SortedDocValues public virtual public virtual decl_stmt Lucene.Net.Index.SortedDocValues = if != return else decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof new long GrowableWriter BytesRef Terms int TermsEnum int PagedBytes int float DocsEnum int int MonotonicAppendingLongBuffer protected internal override protected internal override decl_stmt int = decl_stmt Lucene.Net.Index.Terms = decl_stmt float = float decl_stmt Lucene.Net.Util.PagedBytes = new decl_stmt int decl_stmt int if == = else = + if != decl_stmt long = call Terms.Size() call Terms.Size() call Terms.Size() call Terms.Size() call Terms.Size() if != - if > = = else = else = decl_stmt Lucene.Net.Util.Packed.MonotonicAppendingLongBuffer = new decl_stmt Lucene.Net.Util.Packed.GrowableWriter = new decl_stmt int = if != decl_stmt Lucene.Net.Index.TermsEnum = call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() decl_stmt Lucene.Net.Index.DocsEnum = while decl_stmt Lucene.Net.Util.BytesRef = call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() if == break if >= break call MonotonicAppendingLongBuffer.Add() call MonotonicAppendingLongBuffer.Add() call MonotonicAppendingLongBuffer.Add() call MonotonicAppendingLongBuffer.Add() call MonotonicAppendingLongBuffer.Add() call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) = call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) while decl_stmt int = call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() if == break call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) + ++ call MonotonicAppendingLongBuffer.Freeze() call MonotonicAppendingLongBuffer.Freeze() call MonotonicAppendingLongBuffer.Freeze() call MonotonicAppendingLongBuffer.Freeze() call MonotonicAppendingLongBuffer.Freeze() return new call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) int public override public override decl_stmt int = int if == = = = else public virtual public virtual return FieldInfo BinaryDocValues public virtual public virtual decl_stmt BinaryDocValues = if == = if != return decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return return typeof new int long BytesRef GrowableWriter Terms int TermsEnum decl PackedInts DocsEnum PagedBytes float int int int long protected internal override protected internal override decl_stmt int = decl_stmt Lucene.Net.Index.Terms = decl_stmt float = float decl_stmt int = decl_stmt Lucene.Net.Util.PagedBytes = new decl_stmt int if != decl_stmt long = call Terms.Size() call Terms.Size() call Terms.Size() call Terms.Size() call Terms.Size() if != - if > = = * else = else = decl_stmt Lucene.Net.Util.Packed.GrowableWriter = new call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) new if != decl_stmt int = decl_stmt Lucene.Net.Index.TermsEnum = call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() call Terms.Iterator() decl_stmt Lucene.Net.Index.DocsEnum = while if ++ == break decl_stmt Lucene.Net.Util.BytesRef = call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() call Lucene.Net.Index.TermsEnum.Next() if == break decl_stmt long = call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) call Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(BytesRef) = call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) call Lucene.Net.Index.TermsEnum.Docs(Bits,DocsEnum) while decl_stmt int = call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() call DocsEnum.NextDoc() if == break call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) call Lucene.Net.Util.Packed.GrowableWriter.Set(int,long) decl_stmt Reader = if new return new call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) call Lucene.Net.Util.PagedBytes.Freeze(bool) public virtual public virtual return != public virtual public virtual return SortedSetDocValues FieldInfo SortedDocValues DocTermOrds public virtual public virtual decl_stmt Lucene.Net.Index.SortedSetDocValues = if != return decl_stmt Lucene.Net.Index.SortedDocValues = if != return decl_stmt Lucene.Net.Index.FieldInfo = if == return else if call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() call FieldInfo.HasDocValues() throw new + + + else if ! return decl_stmt Lucene.Net.Index.DocTermOrds = typeof new return call Lucene.Net.Index.DocTermOrds.GetIterator(AtomicReader) call Lucene.Net.Index.DocTermOrds.GetIterator(AtomicReader) call Lucene.Net.Index.DocTermOrds.GetIterator(AtomicReader) call Lucene.Net.Index.DocTermOrds.GetIterator(AtomicReader) call Lucene.Net.Index.DocTermOrds.GetIterator(AtomicReader) protected internal override protected internal override return new = return