org.springframework.scheduling.aspectj java.lang.reflect.Method import java.util.concurrent.Callable import java.util.concurrent.CompletableFuture import java.util.concurrent.ExecutionException import java.util.concurrent.Future import org.junit.Before import org.junit.Test import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler import org.springframework.aop.interceptor.SimpleAsyncUncaughtExceptionHandler import org.springframework.beans.factory.support.DefaultListableBeanFactory import org.springframework.beans.factory.support.RootBeanDefinition import org.springframework.core.task.SimpleAsyncTaskExecutor import org.springframework.scheduling.annotation.Async import org.springframework.scheduling.annotation.AsyncResult import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor import org.springframework.tests.Assume import org.springframework.tests.TestGroup import org.springframework.util.ReflectionUtils import org.springframework.util.concurrent.ListenableFuture import static static org.hamcrest.CoreMatchers.startsWith import static static org.hamcrest.Matchers.not import static static org.junit.Assert.* import class org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspectTests long AsyncUncaughtExceptionHandler CountingExecutor public public = new ClassWithoutAsyncAnnotation public public decl_stmt ClassWithoutAsyncAnnotation = new call ClassWithoutAsyncAnnotation.incrementAsync() call ClassWithoutAsyncAnnotation.incrementAsync() call ClassWithoutAsyncAnnotation.incrementAsync() call ClassWithoutAsyncAnnotation.incrementAsync() call ClassWithoutAsyncAnnotation.incrementAsync() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() decl Future ClassWithoutAsyncAnnotation public public throws decl_stmt ClassWithoutAsyncAnnotation = new decl_stmt java.util.concurrent.Future < = call ClassWithoutAsyncAnnotation.incrementReturningAFuture() call ClassWithoutAsyncAnnotation.incrementReturningAFuture() call ClassWithoutAsyncAnnotation.incrementReturningAFuture() call ClassWithoutAsyncAnnotation.incrementReturningAFuture() call ClassWithoutAsyncAnnotation.incrementReturningAFuture() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() ClassWithoutAsyncAnnotation public public decl_stmt ClassWithoutAsyncAnnotation = new call ClassWithoutAsyncAnnotation.increment() call ClassWithoutAsyncAnnotation.increment() call ClassWithoutAsyncAnnotation.increment() call ClassWithoutAsyncAnnotation.increment() call ClassWithoutAsyncAnnotation.increment() ClassWithAsyncAnnotation public public decl_stmt ClassWithAsyncAnnotation = new call ClassWithAsyncAnnotation.increment() call ClassWithAsyncAnnotation.increment() call ClassWithAsyncAnnotation.increment() call ClassWithAsyncAnnotation.increment() call ClassWithAsyncAnnotation.increment() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() call CountingExecutor.waitForCompletion() decl Future ClassWithAsyncAnnotation public public throws decl_stmt ClassWithAsyncAnnotation = new decl_stmt java.util.concurrent.Future < = call ClassWithAsyncAnnotation.incrementReturningAFuture() call ClassWithAsyncAnnotation.incrementReturningAFuture() call ClassWithAsyncAnnotation.incrementReturningAFuture() call ClassWithAsyncAnnotation.incrementReturningAFuture() call ClassWithAsyncAnnotation.incrementReturningAFuture() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() decl ListenableFuture ClassWithQualifiedAsyncMethods decl CompletableFuture decl Future DefaultListableBeanFactory public public throws decl_stmt org.springframework.beans.factory.support.DefaultListableBeanFactory = new call org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String,BeanDefinition) call org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String,BeanDefinition) call org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String,BeanDefinition) call org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String,BeanDefinition) call org.springframework.beans.factory.support.DefaultListableBeanFactory.registerBeanDefinition(String,BeanDefinition) new decl_stmt ClassWithQualifiedAsyncMethods = new decl_stmt java.util.concurrent.Future < = call ClassWithQualifiedAsyncMethods.defaultWork() call ClassWithQualifiedAsyncMethods.defaultWork() call ClassWithQualifiedAsyncMethods.defaultWork() call ClassWithQualifiedAsyncMethods.defaultWork() call ClassWithQualifiedAsyncMethods.defaultWork() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() call decl Future.get() decl_stmt org.springframework.util.concurrent.ListenableFuture < = call ClassWithQualifiedAsyncMethods.e1Work() call ClassWithQualifiedAsyncMethods.e1Work() call ClassWithQualifiedAsyncMethods.e1Work() call ClassWithQualifiedAsyncMethods.e1Work() call ClassWithQualifiedAsyncMethods.e1Work() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() decl_stmt CompletableFuture < = call ClassWithQualifiedAsyncMethods.e1OtherWork() call ClassWithQualifiedAsyncMethods.e1OtherWork() call ClassWithQualifiedAsyncMethods.e1OtherWork() call ClassWithQualifiedAsyncMethods.e1OtherWork() call ClassWithQualifiedAsyncMethods.e1OtherWork() call decl CompletableFuture.get() call decl CompletableFuture.get() call decl CompletableFuture.get() call decl CompletableFuture.get() call decl CompletableFuture.get() ClassWithException Method TestableAsyncUncaughtExceptionHandler public public decl_stmt com.sun.jdi.Method = decl_stmt org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler = new try call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() decl_stmt ClassWithException = new call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) finally ClassWithException Method TestableAsyncUncaughtExceptionHandler public public decl_stmt com.sun.jdi.Method = decl_stmt org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler = new try call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.isCalled() decl_stmt ClassWithException = new try call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call ClassWithException.failWithVoid() call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.await(long) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) call org.springframework.scheduling.annotation.TestableAsyncUncaughtExceptionHandler.assertCalledWith(Method,Class) catch + finally decl Future public < < public < < < ++ decl_stmt java.util.concurrent.Future < = ++ synchronized return public synchronized public synchronized try catch + + public public ++ public public ++ public < public < ++ return new < public public ++ public < public < ++ return new < public < public < return new < public < public < return new < public < public < return public public throw new