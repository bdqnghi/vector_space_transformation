org.springframework.messaging.simp.stomp java.lang.reflect.Type import java.util.ArrayList import java.util.Arrays import java.util.List import java.util.concurrent.CountDownLatch import java.util.concurrent.TimeUnit import org.apache.activemq.broker.BrokerService import org.apache.commons.logging.Log import org.apache.commons.logging.LogFactory import org.junit.After import org.junit.Before import org.junit.Rule import org.junit.Test import org.junit.rules.TestName import org.springframework.messaging.converter.StringMessageConverter import org.springframework.messaging.simp.stomp.StompSession.Subscription import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler import org.springframework.util.Assert import org.springframework.util.SocketUtils import org.springframework.util.concurrent.ListenableFuture import static static org.hamcrest.Matchers.* import static static org.junit.Assert.* import class org.springframework.messaging.simp.stomp.Reactor2TcpStompClientTests BrokerService Log Reactor2TcpStompClient TestName ThreadPoolTaskScheduler int public public throws call Log.debug() call Log.debug() call Log.debug() call Log.debug() call Log.debug() + + decl_stmt int = = new + * * * * decl_stmt org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler = new call ThreadPoolTaskScheduler.afterPropertiesSet() call ThreadPoolTaskScheduler.afterPropertiesSet() call ThreadPoolTaskScheduler.afterPropertiesSet() call ThreadPoolTaskScheduler.afterPropertiesSet() call ThreadPoolTaskScheduler.afterPropertiesSet() = new new CountDownLatch public public throws try catch call Log.error() call Log.error() call Log.error() call Log.error() call Log.error() decl_stmt java.util.concurrent.CountDownLatch final final = new :: call Log.debug() call Log.debug() call Log.debug() call Log.debug() call Log.debug() if ! call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call Log.debug() call Log.debug() call Log.debug() call Log.debug() call Log.debug() String decl ListenableFuture decl ListenableFuture ProducingHandler ConsumingHandler ConsumingHandler decl ListenableFuture public public throws decl_stmt java.lang.String = decl_stmt ConsumingHandler = new decl_stmt org.springframework.util.concurrent.ListenableFuture < = decl_stmt ConsumingHandler = new decl_stmt org.springframework.util.concurrent.ListenableFuture < = call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() call ConsumingHandler.awaitForSubscriptions() decl_stmt ProducingHandler = new call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() call ProducingHandler.addToSend() decl_stmt org.springframework.util.concurrent.ListenableFuture < = call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.awaitForMessageCount() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call ConsumingHandler.getReceived() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() call decl ListenableFuture.get() public public call Log.error() call Log.error() call Log.error() call Log.error() call Log.error() + + public public call Log.error() call Log.error() call Log.error() call Log.error() call Log.error() + + + public public call Log.error() call Log.error() call Log.error() call Log.error() call Log.error() public < public < return Subscription public public for : decl_stmt Subscription = new public public return public public call Subscription.addReceiptTask() call Subscription.addReceiptTask() call Subscription.addReceiptTask() call Subscription.addReceiptTask() call Subscription.addReceiptTask() :: public public return public public public public throws if call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.debug() call Log.debug() call Log.debug() call Log.debug() call Log.debug() return long public public throws if call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.isDebugEnabled() call Log.debug() call Log.debug() call Log.debug() call Log.debug() call Log.debug() + decl_stmt long = while < if - > return return public public return public public for = < ++