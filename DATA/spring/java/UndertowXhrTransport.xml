org.springframework.web.socket.sockjs.client java.io.ByteArrayOutputStream import java.io.IOException import java.lang.reflect.Method import java.net.URI import java.nio.ByteBuffer import java.util.List import java.util.concurrent.CopyOnWriteArrayList import java.util.concurrent.CountDownLatch import io.undertow.client.ClientCallback import io.undertow.client.ClientConnection import io.undertow.client.ClientExchange import io.undertow.client.ClientRequest import io.undertow.client.ClientResponse import io.undertow.client.UndertowClient import io.undertow.connector.ByteBufferPool import io.undertow.connector.PooledByteBuffer import io.undertow.server.DefaultByteBufferPool import io.undertow.util.AttachmentKey import io.undertow.util.HeaderMap import io.undertow.util.HttpString import io.undertow.util.Methods import io.undertow.util.StringReadChannelListener import org.xnio.ChannelListener import org.xnio.ChannelListeners import org.xnio.IoFuture import org.xnio.IoUtils import org.xnio.OptionMap import org.xnio.Options import org.xnio.Pool import org.xnio.Xnio import org.xnio.XnioWorker import org.xnio.channels.StreamSinkChannel import org.xnio.channels.StreamSourceChannel import org.springframework.http.HttpHeaders import org.springframework.http.HttpStatus import org.springframework.http.ResponseEntity import org.springframework.util.Assert import org.springframework.util.ClassUtils import org.springframework.util.ReflectionUtils import org.springframework.util.concurrent.SettableListenableFuture import org.springframework.web.client.HttpServerErrorException import org.springframework.web.socket.CloseStatus import org.springframework.web.socket.TextMessage import org.springframework.web.socket.WebSocketHandler import org.springframework.web.socket.WebSocketSession import org.springframework.web.socket.sockjs.SockJsException import org.springframework.web.socket.sockjs.SockJsTransportFailureException import org.springframework.web.socket.sockjs.frame.SockJsFrame import class org.springframework.web.socket.sockjs.client.UndertowXhrTransport super super extends decl AttachmentKey UndertowBufferSupport XnioWorker boolean OptionMap UndertowClient public public return public public return protected protected < HttpString ClientRequest HttpHeaders decl ClientCallback private private final final final final final final final final final final final < if + decl_stmt ClientCallback < = new < public public decl_stmt ClientRequest = new decl_stmt HttpString = call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() decl_stmt org.springframework.http.HttpHeaders = public public throw new + HttpString ClientRequest HttpHeaders public public decl_stmt ClientRequest = new decl_stmt HttpString = call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() decl_stmt org.springframework.http.HttpHeaders = public public throw new + HeaderMap private static private static decl_stmt HeaderMap = for : for : call HeaderMap.add() call HeaderMap.add() call HeaderMap.add() call HeaderMap.add() call HeaderMap.add() HttpStatus SockJsResponseListener ClientResponse StreamSinkChannel private < private < final final final final final final final final final final final < return new < public public final final new < public public decl_stmt ClientResponse = if call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() != decl_stmt HttpStatus = call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() new else decl_stmt SockJsResponseListener = new call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() if + call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() try decl_stmt StreamSinkChannel = call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() if ! call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() > call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() catch public public public public private private if return if else new HttpStatus SockJsResponseListener ClientResponse StreamSinkChannel public public final final new < public public decl_stmt ClientResponse = if call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() != decl_stmt HttpStatus = call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() new else decl_stmt SockJsResponseListener = new call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() if + call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() try decl_stmt StreamSinkChannel = call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() if ! call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() > call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() catch public public HttpStatus SockJsResponseListener ClientResponse StreamSinkChannel public public decl_stmt ClientResponse = if call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() != decl_stmt HttpStatus = call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() new else decl_stmt SockJsResponseListener = new call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() call SockJsResponseListener.setup() if + call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() try decl_stmt StreamSinkChannel = call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() call StreamSinkChannel.shutdownWrites() if ! call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.flush() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() call StreamSinkChannel.getWriteSetter() > call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() call StreamSinkChannel.resumeWrites() catch public public public public private private if return if else new HttpHeaders private static private static decl_stmt org.springframework.http.HttpHeaders = new for : for : call org.springframework.http.HttpHeaders.add(String,String) call org.springframework.http.HttpHeaders.add(String,String) call org.springframework.http.HttpHeaders.add(String,String) call org.springframework.http.HttpHeaders.add(String,String) call org.springframework.http.HttpHeaders.add(String,String) return protected < protected < return protected < protected < return HttpStatus decl List HttpString ClientRequest String ClientConnection HttpHeaders CountDownLatch ClientResponse protected < protected < decl_stmt java.util.concurrent.CountDownLatch = new decl_stmt java.util.List < = new < try decl_stmt ClientConnection = try decl_stmt ClientRequest = new call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() if != && ! decl_stmt HttpString = call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientRequest.getRequestHeaders() call ClientConnection.sendRequest() call ClientConnection.sendRequest() call ClientConnection.sendRequest() call ClientConnection.sendRequest() call ClientConnection.sendRequest() call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) call java.util.concurrent.CountDownLatch.await(long,TimeUnit) decl_stmt ClientResponse = call decl List.iterator() call decl List.iterator() call decl List.iterator() call decl List.iterator() call decl List.iterator() decl_stmt HttpStatus = call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() call ClientResponse.getResponseCode() decl_stmt org.springframework.http.HttpHeaders = call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() call ClientResponse.getResponseHeaders() decl_stmt java.lang.String = call ClientResponse.getAttachment() call ClientResponse.getAttachment() call ClientResponse.getAttachment() call ClientResponse.getAttachment() call ClientResponse.getAttachment() return != new < : new < finally catch throw new + catch throw new + private < private < final final final final final < final final return new < public public new < public public final final new protected protected protected protected public public try if != if ! > catch public public private private throw new public public new < public public final final new protected protected protected protected public public try if != if ! > catch public public final final new protected protected protected protected protected protected protected protected public public public public private private throw new public public ByteBuffer int Object int public public if if throw new decl_stmt java.lang.Object = call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.allocatePooledResource() call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.allocatePooledResource() call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.allocatePooledResource() call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.allocatePooledResource() call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.allocatePooledResource() try decl_stmt int do decl_stmt ByteBuffer = call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.getByteBuffer(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.getByteBuffer(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.getByteBuffer(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.getByteBuffer(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.getByteBuffer(Object) call ByteBuffer.clear() call ByteBuffer.clear() call ByteBuffer.clear() call ByteBuffer.clear() call ByteBuffer.clear() = call ByteBuffer.flip() call ByteBuffer.flip() call ByteBuffer.flip() call ByteBuffer.flip() call ByteBuffer.flip() if == return else if == - else while call ByteBuffer.hasRemaining() call ByteBuffer.hasRemaining() call ByteBuffer.hasRemaining() call ByteBuffer.hasRemaining() call ByteBuffer.hasRemaining() decl_stmt int = call ByteBuffer.get() call ByteBuffer.get() call ByteBuffer.get() call ByteBuffer.get() call ByteBuffer.get() if == else > catch finally call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.closePooledResource(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.closePooledResource(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.closePooledResource(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.closePooledResource(Object) call org.springframework.web.socket.sockjs.client.UndertowBufferSupport.closePooledResource(Object) String decl byte private private decl_stmt byte = decl_stmt java.lang.String = new if + if ! new public public if > if public public if return if else new public public return public public return < public public < public public < public < public < return < public public return public public return public public public public < public < public < return <