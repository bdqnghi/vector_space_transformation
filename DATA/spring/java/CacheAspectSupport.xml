org.springframework.cache.interceptor java.lang.reflect.Method import java.util.ArrayList import java.util.Collection import java.util.Collections import java.util.LinkedList import java.util.List import java.util.Map import java.util.concurrent.Callable import java.util.concurrent.ConcurrentHashMap import org.apache.commons.logging.Log import org.apache.commons.logging.LogFactory import org.springframework.aop.framework.AopProxyUtils import org.springframework.beans.factory.InitializingBean import org.springframework.beans.factory.NoSuchBeanDefinitionException import org.springframework.beans.factory.NoUniqueBeanDefinitionException import org.springframework.beans.factory.SmartInitializingSingleton import org.springframework.beans.factory.annotation.BeanFactoryAnnotationUtils import org.springframework.cache.Cache import org.springframework.cache.CacheManager import org.springframework.cache.support.SimpleValueWrapper import org.springframework.context.ApplicationContext import org.springframework.context.ApplicationContextAware import org.springframework.context.expression.AnnotatedElementKey import org.springframework.expression.EvaluationContext import org.springframework.util.Assert import org.springframework.util.ClassUtils import org.springframework.util.CollectionUtils import org.springframework.util.LinkedMultiValueMap import org.springframework.util.MultiValueMap import org.springframework.util.ObjectUtils import org.springframework.util.StringUtils import class org.springframework.cache.interceptor.CacheAspectSupport super super extends super implements ApplicationContext CacheResolver KeyGenerator CacheOperationSource boolean ExpressionEvaluator Log decl Map public public = > new : public public return public public = public public return public public = new public public = public public return public public = public public != + != public public if == try catch throw new + + catch throw new + = Method protected protected < decl_stmt com.sun.jdi.Method = return decl Collection protected < extends extends protected < extends extends < decl_stmt java.util.Collection < extends extends = call CacheResolver.resolveCaches() call CacheResolver.resolveCaches() call CacheResolver.resolveCaches() call CacheResolver.resolveCaches() call CacheResolver.resolveCaches() if call decl Collection.isEmpty() call decl Collection.isEmpty() call decl Collection.isEmpty() call decl Collection.isEmpty() call decl Collection.isEmpty() throw new + + + + return CacheOperationMetadata protected protected < decl_stmt CacheOperationMetadata = return new KeyGenerator CacheOperationCacheKey CacheResolver CacheManager CacheOperationMetadata protected protected < decl_stmt CacheOperationCacheKey = new decl_stmt CacheOperationMetadata = if == decl_stmt org.springframework.cache.interceptor.KeyGenerator if = else = decl_stmt org.springframework.cache.interceptor.CacheResolver if = else if decl_stmt org.springframework.cache.CacheManager = = new else = = new return protected < protected < < return protected protected decl Collection decl Class protected protected if decl_stmt java.lang.Class < = decl_stmt java.util.Collection < = if ! return new return protected protected return decl Class private < private < decl_stmt java.lang.Class < = if == && != = return decl ValueWrapper CacheOperationContext Cache decl Cache decl List Object private private final final if decl_stmt CacheOperationContext = if decl_stmt java.lang.Object = decl_stmt org.springframework.cache.Cache = call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() try return call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) new < public public throws return catch throw else return decl_stmt ValueWrapper = decl_stmt java.util.List < = new < if == decl_stmt ValueWrapper = if call decl ValueWrapper.isEmpty() call decl ValueWrapper.isEmpty() call decl ValueWrapper.isEmpty() call decl ValueWrapper.isEmpty() call decl ValueWrapper.isEmpty() && ! = if == = new call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() for : call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() return call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() public public throws return decl Collection decl Collection private private decl_stmt java.util.Collection < = decl_stmt java.util.Collection < = new < for : try if ! call decl Collection.add() call decl Collection.add() call decl Collection.add() call decl Collection.add() call decl Collection.add() catch return call decl Collection.size() call decl Collection.size() call decl Collection.size() call decl Collection.size() call decl Collection.size() != call decl Collection.size() call decl Collection.size() call decl Collection.size() call decl Collection.size() call decl Collection.size() CacheEvictOperation private private < for : decl_stmt org.springframework.cache.interceptor.CacheEvictOperation = if == call org.springframework.cache.interceptor.CacheEvictOperation.isBeforeInvocation() call org.springframework.cache.interceptor.CacheEvictOperation.isBeforeInvocation() call org.springframework.cache.interceptor.CacheEvictOperation.isBeforeInvocation() call org.springframework.cache.interceptor.CacheEvictOperation.isBeforeInvocation() call org.springframework.cache.interceptor.CacheEvictOperation.isBeforeInvocation() && Object private private decl_stmt java.lang.Object = for : if else if == = private private if call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.trace() call Log.trace() call Log.trace() call Log.trace() call Log.trace() + != + + : + + + + decl Cache Object Object private private < decl_stmt java.lang.Object = for : if decl_stmt java.lang.Object = decl_stmt ValueWrapper = if != return else if call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.trace() call Log.trace() call Log.trace() call Log.trace() call Log.trace() + + + return Object private private < < for : if decl_stmt java.lang.Object = new decl Cache private private for : decl_stmt ValueWrapper = if != if call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.trace() call Log.trace() call Log.trace() call Log.trace() call Log.trace() + + + + return return boolean private private decl_stmt boolean = if ! && call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.trace() call Log.trace() call Log.trace() call Log.trace() call Log.trace() + + + return Object private private decl_stmt java.lang.Object = if == throw new + + if call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.isTraceEnabled() call Log.trace() call Log.trace() call Log.trace() call Log.trace() call Log.trace() + + + return decl Collection public < public < < extends extends decl_stmt java.util.Collection < = return != : > public public return CacheableOperation decl List CacheOperationContext boolean private private decl_stmt java.util.List < = if == return decl_stmt boolean = for : if call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() = break if if > throw new + + if call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() > throw new + + decl_stmt CacheOperationContext = call decl List.iterator() call decl List.iterator() call decl List.iterator() call decl List.iterator() call decl List.iterator() decl_stmt org.springframework.cache.interceptor.CacheableOperation = call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() call CacheOperationContext.getOperation() if call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() call CacheOperationContext.getCaches() > throw new + + if call org.springframework.cache.interceptor.CacheableOperation.getUnless() call org.springframework.cache.interceptor.CacheableOperation.getUnless() call org.springframework.cache.interceptor.CacheableOperation.getUnless() call org.springframework.cache.interceptor.CacheableOperation.getUnless() call org.springframework.cache.interceptor.CacheableOperation.getUnless() throw new + + return return public public return public public return public public return public public return decl Object decl Object private private if ! return decl_stmt java.lang.Object = - decl_stmt java.lang.Object = new - + - - return EvaluationContext protected protected if decl_stmt org.springframework.expression.EvaluationContext = return call ExpressionEvaluator.condition() call ExpressionEvaluator.condition() call ExpressionEvaluator.condition() call ExpressionEvaluator.condition() call ExpressionEvaluator.condition() return String EvaluationContext protected protected decl_stmt java.lang.String = if instanceof = else if instanceof = if decl_stmt org.springframework.expression.EvaluationContext = return ! call org.springframework.cache.interceptor.ExpressionEvaluator.unless(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.unless(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.unless(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.unless(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.unless(String,AnnotatedElementKey,EvaluationContext) return EvaluationContext protected protected if decl_stmt org.springframework.expression.EvaluationContext = return call org.springframework.cache.interceptor.ExpressionEvaluator.key(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.key(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.key(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.key(String,AnnotatedElementKey,EvaluationContext) call org.springframework.cache.interceptor.ExpressionEvaluator.key(String,AnnotatedElementKey,EvaluationContext) return private private return call org.springframework.cache.interceptor.ExpressionEvaluator.createEvaluationContext(Collection,Method,Object,Object,Class,BeanFactory) call org.springframework.cache.interceptor.ExpressionEvaluator.createEvaluationContext(Collection,Method,Object,Object,Class,BeanFactory) call org.springframework.cache.interceptor.ExpressionEvaluator.createEvaluationContext(Collection,Method,Object,Object,Class,BeanFactory) call org.springframework.cache.interceptor.ExpressionEvaluator.createEvaluationContext(Collection,Method,Object,Object,Class,BeanFactory) call org.springframework.cache.interceptor.ExpressionEvaluator.createEvaluationContext(Collection,Method,Object,Object,Class,BeanFactory) protected < extends extends protected < extends extends return protected < protected < return decl Collection private < private < < extends extends decl_stmt java.util.Collection < = new < for : call decl Collection.add() call decl Collection.add() call decl Collection.add() call decl Collection.add() call decl Collection.add() return public public if for : CacheOperationCacheKey public public if == return if ! instanceof return decl_stmt CacheOperationCacheKey = return && public public return * + public public return + + int public public decl_stmt int = if == = return