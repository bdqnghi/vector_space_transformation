org.springframework.cache.jcache.interceptor java.io.IOException import java.util.concurrent.ConcurrentHashMap import java.util.concurrent.atomic.AtomicLong import javax.cache.annotation.CacheDefaults import javax.cache.annotation.CacheKey import javax.cache.annotation.CachePut import javax.cache.annotation.CacheRemove import javax.cache.annotation.CacheRemoveAll import javax.cache.annotation.CacheResult import javax.cache.annotation.CacheValue import org.springframework.cache.Cache import org.springframework.cache.interceptor.SimpleKeyGenerator import org.springframework.cache.jcache.config.JCacheableService import org.springframework.cache.jcache.support.TestableCacheKeyGenerator import org.springframework.cache.jcache.support.TestableCacheResolverFactory import class annotation org.springframework.cache.jcache.interceptor.AnnotatedJCacheableService super super implements Cache AtomicLong AtomicLong public public return call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() public public return = = public = = public return = = public = = public throws return = public = public return call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() public public return call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() = public = public return call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() = public = public return call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() public public = public = public decl ValueWrapper decl Cache Object = public = public decl_stmt java.lang.Object = decl_stmt ValueWrapper = call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) if == throw new + decl_stmt java.lang.Object = call decl Cache.get() call decl Cache.get() call decl Cache.get() call decl Cache.get() call decl Cache.get() if != throw new + + + + + + = public = public public public = public = public decl Cache Object = public = public decl_stmt java.lang.Object = decl_stmt ValueWrapper = call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) call org.springframework.cache.Cache.get(Object,Class) if != throw new + + = = public = = public public public = public = public decl ConcurrentHashMap = public = public decl_stmt java.util.concurrent.ConcurrentHashMap < = < call org.springframework.cache.Cache.getNativeCache() call org.springframework.cache.Cache.getNativeCache() call org.springframework.cache.Cache.getNativeCache() call org.springframework.cache.Cache.getNativeCache() call org.springframework.cache.Cache.getNativeCache() if ! call decl ConcurrentHashMap.isEmpty() call decl ConcurrentHashMap.isEmpty() call decl ConcurrentHashMap.isEmpty() call decl ConcurrentHashMap.isEmpty() call decl ConcurrentHashMap.isEmpty() throw new = = public = = public public public public public return call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() call java.util.concurrent.atomic.AtomicLong.get() long private private decl_stmt long = call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() if throw new + + else throw new + + long private private throws decl_stmt long = call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() call java.util.concurrent.atomic.AtomicLong.getAndIncrement() if throw new + + else throw new + +