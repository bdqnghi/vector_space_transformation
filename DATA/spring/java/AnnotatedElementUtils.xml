org.springframework.core.annotation java.lang.annotation.Annotation import java.lang.reflect.AnnotatedElement import java.lang.reflect.Method import java.util.ArrayList import java.util.Arrays import java.util.HashSet import java.util.LinkedHashSet import java.util.List import java.util.Map import java.util.Set import org.springframework.core.BridgeMethodResolver import org.springframework.util.Assert import org.springframework.util.LinkedMultiValueMap import org.springframework.util.MultiValueMap import class org.springframework.core.annotation.AnnotatedElementUtils decl Processor Boolean decl Annotation public static public static final final return new public < extends extends public < extends extends < for : if == return return public public return public public return public < extends extends public < extends extends < for : if == return return public public return public public return public static < public static < < extends extends return public static < public static < return decl Set private static < private static < if == return try decl_stmt java.util.Set final final final < = new < new < public public call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() return new < return ! call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() call decl Set.isEmpty() : catch throw new + public public return public static public static < extends extends return public static public static return private static private static < extends extends return new < public public return > : public public return > : public static public static < extends extends if return return public static public static return public static public static return public static public static return AnnotationAttributes public static public static < extends extends decl_stmt org.springframework.core.annotation.AnnotationAttributes = new return public static public static return AnnotationAttributes public static public static decl_stmt org.springframework.core.annotation.AnnotationAttributes = new return AnnotationAttributes A public static < extends extends public static < extends extends < if ! instanceof decl_stmt org.springframework.expression.spel.spr10210.A = if != return decl_stmt org.springframework.core.annotation.AnnotationAttributes = return MergedAnnotationAttributesProcessor public static < extends extends < public static < extends extends < < decl_stmt MergedAnnotationAttributesProcessor = new return call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() public static < extends extends < public static < extends extends < < return MergedAnnotationAttributesProcessor public static < extends extends < public static < extends extends < < < extends extends if == = else decl_stmt MergedAnnotationAttributesProcessor = new return call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() public static < public static < return AnnotationAttributes decl MultiValueMap public static < public static < final final final final decl_stmt org.springframework.util.MultiValueMap final final final < = new < new < public public decl_stmt org.springframework.core.annotation.AnnotationAttributes = for < : call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call decl MultiValueMap.add() call decl MultiValueMap.add() call decl MultiValueMap.add() call decl MultiValueMap.add() call decl MultiValueMap.add() return return ! call decl MultiValueMap.isEmpty() call decl MultiValueMap.isEmpty() call decl MultiValueMap.isEmpty() call decl MultiValueMap.isEmpty() call decl MultiValueMap.isEmpty() : AnnotationAttributes public public decl_stmt org.springframework.core.annotation.AnnotationAttributes = for < : call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() call AnnotationAttributes.entrySet() return public static public static < extends extends if return return AnnotationAttributes public static public static < extends extends decl_stmt org.springframework.core.annotation.AnnotationAttributes = new return AnnotationAttributes public static public static decl_stmt org.springframework.core.annotation.AnnotationAttributes = new return AnnotationAttributes A public static < extends extends public static < extends extends < if ! instanceof decl_stmt org.springframework.expression.spel.spr10210.A = if != return decl_stmt org.springframework.core.annotation.AnnotationAttributes = return AnnotationAttributes public static < extends extends public static < extends extends decl_stmt org.springframework.core.annotation.AnnotationAttributes = return < call org.springframework.core.annotation.AnnotationAttributes.annotationType() call org.springframework.core.annotation.AnnotationAttributes.annotationType() call org.springframework.core.annotation.AnnotationAttributes.annotationType() call org.springframework.core.annotation.AnnotationAttributes.annotationType() call org.springframework.core.annotation.AnnotationAttributes.annotationType() MergedAnnotationAttributesProcessor public static < extends extends < public static < extends extends < < decl_stmt MergedAnnotationAttributesProcessor = new return call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() public static < extends extends < public static < extends extends < < return MergedAnnotationAttributesProcessor public static < extends extends < public static < extends extends < < < extends extends if == = else decl_stmt MergedAnnotationAttributesProcessor = new return call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() call MergedAnnotationAttributesProcessor.getAggregatedResults() private static < private static < < extends extends < return private static < private static < < extends extends < extends extends < try return new < catch throw new + decl List T decl List private static < private static < < extends extends < extends extends < < if try decl_stmt java.util.List < = decl_stmt T = if != return if instanceof decl_stmt java.util.List < = new < for : if ! call decl List.contains() call decl List.contains() call decl List.contains() call decl List.contains() call decl List.contains() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() = if != return catch return T private static < private static < < < extends extends < extends extends < < for : if ! if == || || decl_stmt T = if != if && == else return else if == for : decl_stmt T = if != for : if ! decl_stmt T = + if != if && == else return return private static < private static < < extends extends < return private static < private static < < extends extends < extends extends < if != && ! throw new try return new < catch throw new + Method decl List decl Class decl Class Method T decl Annotation T Method decl Class private static < private static < < extends extends < extends extends < < if try decl_stmt java.text.Annotation = decl_stmt java.util.List < = new < : for : if ! if == || || decl_stmt T = if != if && == call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() else return else if == for : decl_stmt T = if != call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() for : if ! decl_stmt T = + if != if && == call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() else return if if instanceof decl_stmt com.sun.jdi.Method = decl_stmt com.sun.jdi.Method = decl_stmt T = if != return decl_stmt com.sun.jdi.Method = decl_stmt com.sun.jdi.Method = decl_stmt T = if != return = if != return decl_stmt java.lang.Class < = call com.sun.jdi.Method.getDeclaringClass() call com.sun.jdi.Method.getDeclaringClass() call com.sun.jdi.Method.getDeclaringClass() call com.sun.jdi.Method.getDeclaringClass() call com.sun.jdi.Method.getDeclaringClass() while = call T.getSuperclass() call T.getSuperclass() call T.getSuperclass() call T.getSuperclass() call T.getSuperclass() if == || == break try decl_stmt com.sun.jdi.Method = call T.getDeclaredMethod() call T.getDeclaredMethod() call T.getDeclaredMethod() call T.getDeclaredMethod() call T.getDeclaredMethod() call com.sun.jdi.Method.getName() call com.sun.jdi.Method.getName() call com.sun.jdi.Method.getName() call com.sun.jdi.Method.getName() call com.sun.jdi.Method.getName() call com.sun.jdi.Method.getParameterTypes() call com.sun.jdi.Method.getParameterTypes() call com.sun.jdi.Method.getParameterTypes() call com.sun.jdi.Method.getParameterTypes() call com.sun.jdi.Method.getParameterTypes() decl_stmt com.sun.jdi.Method = = if != return catch = call T.getInterfaces() call T.getInterfaces() call T.getInterfaces() call T.getInterfaces() call T.getInterfaces() if != return else if instanceof decl_stmt java.lang.Class < = < for < : call T.getInterfaces() call T.getInterfaces() call T.getInterfaces() call T.getInterfaces() call T.getInterfaces() decl_stmt T = if != return decl_stmt java.lang.Class < = call T.getSuperclass() call T.getSuperclass() call T.getSuperclass() call T.getSuperclass() call T.getSuperclass() if != && != decl_stmt T = if != return catch return Method T private static < private static < < extends extends < extends extends < < < for < : if try decl_stmt com.sun.jdi.Method = decl_stmt T = if != return catch return private static < extends extends private static < extends extends try return catch return decl Class private static < extends extends private static < extends extends < extends extends decl_stmt java.lang.Class < extends extends = if == throw new + return decl Class String Method private static private static < extends extends < extends extends try decl_stmt com.sun.jdi.Method = decl_stmt java.lang.Class < = call com.sun.jdi.Method.getReturnType() call com.sun.jdi.Method.getReturnType() call com.sun.jdi.Method.getReturnType() call com.sun.jdi.Method.getReturnType() call com.sun.jdi.Method.getReturnType() if ! call decl Class.isArray() call decl Class.isArray() call decl Class.isArray() call decl Class.isArray() call decl Class.isArray() || call decl Class.getComponentType() call decl Class.getComponentType() call decl Class.getComponentType() call decl Class.getComponentType() call decl Class.getComponentType() != decl_stmt java.lang.String = throw new catch decl_stmt java.lang.String = throw new decl Set private static < extends extends < private static < extends extends < < < decl_stmt java.util.Set < = new < for : call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() return public final public final return public final public final public final public final return public final < public final < throw new public final public final return public public return public public return public < public < return public public return decl Class decl Set String String decl List decl List public public = decl_stmt java.lang.Class < extends extends = decl_stmt java.util.Set < = new < for : decl_stmt java.lang.String = decl_stmt java.lang.String = if != if call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() continue decl_stmt java.util.List < = new < call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() decl_stmt java.util.List < = if != for : if ! call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl Set.contains() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() else if ! && Object private private < decl_stmt java.lang.Object = for : private private Object private private decl_stmt java.lang.Object = return