org.apache.log4j java.util.Hashtable import java.util.Stack import java.util.Enumeration import java.util.Vector import org.apache.log4j.helpers.LogLog import class org.apache.log4j.NDC int int Hashtable private static private static if != return call java.util.Hashtable.get(Object) call java.util.Hashtable.get(Object) call java.util.Hashtable.get(Object) call java.util.Hashtable.get(Object) call java.util.Hashtable.get(Object) return Stack public static public static decl_stmt java.util.Stack = if != call Stack.setSize() call Stack.setSize() call Stack.setSize() call Stack.setSize() call Stack.setSize() Stack public static public static decl_stmt java.util.Stack = if == return else return call Stack.clone() call Stack.clone() call Stack.clone() call Stack.clone() call Stack.clone() public static public static if != call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) Stack static public static public decl_stmt java.util.Stack = if != && ! call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() return call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() else return Stack public static public static decl_stmt java.util.Stack = if == return else return call Stack.size() call Stack.size() call Stack.size() call Stack.size() call Stack.size() int int Thread Enumeration Vector private static private static if == return decl_stmt java.util.Vector synchronized if ++ <= return else = decl_stmt int = = new decl_stmt java.util.Enumeration = call java.util.Hashtable.keys() call java.util.Hashtable.keys() call java.util.Hashtable.keys() call java.util.Hashtable.keys() call java.util.Hashtable.keys() while call Enumeration.hasMoreElements() call Enumeration.hasMoreElements() call Enumeration.hasMoreElements() call Enumeration.hasMoreElements() call Enumeration.hasMoreElements() && <= decl_stmt java.lang.Thread = call java.util.Enumeration.nextElement() call java.util.Enumeration.nextElement() call java.util.Enumeration.nextElement() call java.util.Enumeration.nextElement() call java.util.Enumeration.nextElement() if call Thread.isAlive() call Thread.isAlive() call Thread.isAlive() call Thread.isAlive() call Thread.isAlive() ++ else = call java.util.Vector.addElement(E) call java.util.Vector.addElement(E) call java.util.Vector.addElement(E) call java.util.Vector.addElement(E) call java.util.Vector.addElement(E) decl_stmt int = call java.util.Vector.size() call java.util.Vector.size() call java.util.Vector.size() call java.util.Vector.size() call java.util.Vector.size() for = < ++ decl_stmt java.lang.Thread = call java.util.Vector.elementAt(int) call java.util.Vector.elementAt(int) call java.util.Vector.elementAt(int) call java.util.Vector.elementAt(int) call java.util.Vector.elementAt(int) + call java.lang.Thread.getName() call java.lang.Thread.getName() call java.lang.Thread.getName() call java.lang.Thread.getName() call java.lang.Thread.getName() + + call java.util.Hashtable.size() call java.util.Hashtable.size() call java.util.Hashtable.size() call java.util.Hashtable.size() call java.util.Hashtable.size() + call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) Stack public static public static decl_stmt java.util.Stack = if != && ! call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() return call Stack.pop() call Stack.pop() call Stack.pop() call Stack.pop() call Stack.pop() else return Stack public static public static decl_stmt java.util.Stack = if != && ! call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() return call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() else return DiagnosticContext Stack Thread DiagnosticContext public static public static decl_stmt java.util.Stack = if == decl_stmt DiagnosticContext = new = new decl_stmt java.lang.Thread = call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Hashtable.put(K,V) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) else if call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() call Stack.isEmpty() decl_stmt DiagnosticContext = new call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) else decl_stmt DiagnosticContext = call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.peek() call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) call java.util.Stack.push(E) new static public static public if != call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) call java.util.Hashtable.remove(Object) Stack static public static public decl_stmt java.util.Stack = if != && < call Stack.size() call Stack.size() call Stack.size() call Stack.size() call Stack.size() call Stack.setSize() call Stack.setSize() call Stack.setSize() call Stack.setSize() call Stack.setSize()