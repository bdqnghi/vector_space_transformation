org.zeromq zmq.Ctx import zmq.SocketBase import zmq.ZMQ import java.util.HashSet import java.util.Set import java.util.concurrent.locks.Lock import java.util.concurrent.locks.ReentrantLock import class org.zeromq.ManagedContext Lock Ctx decl Set public public static static return SocketBase decl_stmt zmq.SocketBase final final = call zmq.Ctx.createSocket(int) call zmq.Ctx.createSocket(int) call zmq.Ctx.createSocket(int) call zmq.Ctx.createSocket(int) call zmq.Ctx.createSocket(int) call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() call decl Set.add() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() return try catch call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() call decl Set.remove() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() private private call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try for : try catch call decl Set.clear() call decl Set.clear() call decl Set.clear() call decl Set.clear() call decl Set.clear() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock()