zmq java.io.IOException import java.util.ArrayDeque import java.util.ArrayList import java.util.Deque import java.util.HashMap import java.util.Iterator import java.util.List import java.util.Map import java.util.Map.Entry import java.util.concurrent.atomic.AtomicBoolean import java.util.concurrent.atomic.AtomicInteger import java.util.concurrent.locks.Lock import java.util.concurrent.locks.ReentrantLock import class zmq.Ctx AtomicInteger Lock int int int Lock decl Deque Lock boolean Reaper Mailbox int int decl List int decl Mailbox decl Map AtomicBoolean decl List boolean private private throws for : for : if != call zmq.Reaper.close() call zmq.Reaper.close() call zmq.Reaper.close() call zmq.Reaper.close() call zmq.Reaper.close() call zmq.Mailbox.close() call zmq.Mailbox.close() call zmq.Mailbox.close() call zmq.Mailbox.close() call zmq.Mailbox.close() = public public return == Command boolean public public = if ! call java.util.concurrent.atomic.AtomicBoolean.get() call java.util.concurrent.atomic.AtomicBoolean.get() call java.util.concurrent.atomic.AtomicBoolean.get() call java.util.concurrent.atomic.AtomicBoolean.get() call java.util.concurrent.atomic.AtomicBoolean.get() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try decl_stmt boolean = = if ! for : if call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call zmq.Reaper.stop() call zmq.Reaper.stop() call zmq.Reaper.stop() call zmq.Reaper.stop() call zmq.Reaper.stop() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() decl_stmt zmq.Command = call zmq.Mailbox.recv(long) call zmq.Mailbox.recv(long) call zmq.Mailbox.recv(long) call zmq.Mailbox.recv(long) call zmq.Mailbox.recv(long) - if == throw new assert call zmq.Command.type() call zmq.Command.type() call zmq.Command.type() call zmq.Command.type() call zmq.Command.type() == call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try assert call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() try catch throw new public public if == && >= call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try = finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() else if == && >= call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try = finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() else if == && >= call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try = != finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() else return return int public public decl_stmt int = if == = else if == = else if == = : else throw new + return int int int SocketBase IOThread int public public decl_stmt zmq.SocketBase = call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try if call java.util.concurrent.atomic.AtomicBoolean.compareAndSet(boolean,boolean) call java.util.concurrent.atomic.AtomicBoolean.compareAndSet(boolean,boolean) call java.util.concurrent.atomic.AtomicBoolean.compareAndSet(boolean,boolean) call java.util.concurrent.atomic.AtomicBoolean.compareAndSet(boolean,boolean) call java.util.concurrent.atomic.AtomicBoolean.compareAndSet(boolean,boolean) decl_stmt int decl_stmt int call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try = = finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() = + + = new = = new = call zmq.Reaper.getMailbox() call zmq.Reaper.getMailbox() call zmq.Reaper.getMailbox() call zmq.Reaper.getMailbox() call zmq.Reaper.getMailbox() call Reaper.start() call Reaper.start() call Reaper.start() call Reaper.start() call Reaper.start() for = != + ++ decl_stmt zmq.IOThread = new call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() = call zmq.IOThread.getMailbox() call zmq.IOThread.getMailbox() call zmq.IOThread.getMailbox() call zmq.IOThread.getMailbox() call zmq.IOThread.getMailbox() call zmq.IOThread.start() call zmq.IOThread.start() call zmq.IOThread.start() call zmq.IOThread.start() call zmq.IOThread.start() for = int - >= int + -- call decl Deque.add() call decl Deque.add() call decl Deque.add() call decl Deque.add() call decl Deque.add() = if throw new if call decl Deque.isEmpty() call decl Deque.isEmpty() call decl Deque.isEmpty() call decl Deque.isEmpty() call decl Deque.isEmpty() throw new decl_stmt int = call decl Deque.pollLast() call decl Deque.pollLast() call decl Deque.pollLast() call decl Deque.pollLast() call decl Deque.pollLast() decl_stmt int = call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() call java.util.concurrent.atomic.AtomicInteger.incrementAndGet() = if == call decl Deque.addLast() call decl Deque.addLast() call decl Deque.addLast() call decl Deque.addLast() call decl Deque.addLast() return call decl List.add() call decl List.add() call decl List.add() call decl List.add() call decl List.add() = call zmq.SocketBase.getMailbox() call zmq.SocketBase.getMailbox() call zmq.SocketBase.getMailbox() call zmq.SocketBase.getMailbox() call zmq.SocketBase.getMailbox() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() return int public public call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try decl_stmt int = call decl Deque.add() call decl Deque.add() call decl Deque.add() call decl Deque.add() call decl Deque.add() = call decl List.remove() call decl List.remove() call decl List.remove() call decl List.remove() call decl List.remove() if && call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call zmq.Reaper.stop() call zmq.Reaper.stop() call zmq.Reaper.stop() call zmq.Reaper.stop() call zmq.Reaper.stop() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() return final final int IOThread int if call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() call decl List.isEmpty() return decl_stmt int = - decl_stmt zmq.IOThread = for = != call decl List.size() call decl List.size() call decl List.size() call decl List.size() call decl List.size() ++ if == || & << > decl_stmt int = call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() if == || < = = call decl List.get() call decl List.get() call decl List.get() call decl List.get() call decl List.get() return Endpoint call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() decl_stmt sun.rmi.transport.Endpoint = try = call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() call decl Map.put() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() if != return return decl Entry decl Iterator call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try decl_stmt java.util.Iterator < < = call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() call decl Map.entrySet() while call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() call decl Iterator.hasNext() decl_stmt Entry < = call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() call decl Iterator.next() if call decl Entry.getValue() call decl Entry.getValue() call decl Entry.getValue() call decl Entry.getValue() call decl Entry.getValue() == call decl Iterator.remove() call decl Iterator.remove() call decl Iterator.remove() call decl Iterator.remove() call decl Iterator.remove() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() Endpoint decl_stmt sun.rmi.transport.Endpoint = call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() call Lock.lock() try = call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() call decl Map.get() if == return new new call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() call Endpoint.socket() finally call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() call java.util.concurrent.locks.Lock.unlock() return