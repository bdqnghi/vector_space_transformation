NetMQ.Security.V0_1 System using System.Linq using System.Security.Cryptography using System.Security.Cryptography.X509Certificates using NetMQ.Security.V0_1.HandshakeMessages using class NetMQ.Security.V0_1.HandshakeLayer super super IDisposable RandomNumberGenerator int int SHA256 HandshakeType string string bool IPRF string HandshakeType SecureChannel SHA256 var public public if == if == && == && == return else throw new decl_stmt var = switch case break case break case break case break case break case break default: throw new = return private private private private private private decl byte private static private static foreach in decl_stmt byte = NetMQMessage var private private decl_stmt var = new = new call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) = = decl_stmt NetMQMessage = call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() = var private private if != || != throw new decl_stmt var = new call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() = NetMQMessage var private private decl_stmt var = new decl_stmt NetMQMessage = call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() = var NetMQMessage private private decl_stmt var = new = decl_stmt NetMQMessage = call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() = NetMQMessage var private private decl_stmt var = new = new call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) = = foreach in if = break decl_stmt NetMQMessage = call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() = var private private if != || != throw new decl_stmt var = new call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() = var private private if != || != throw new decl_stmt var = new call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() if ! throw new = var private private if != || != throw new decl_stmt var = new call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() NetMQMessage var var var private private decl_stmt var = new decl_stmt var = new call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) call System.Security.Cryptography.RandomNumberGenerator.GetBytes(byte,int,int) decl_stmt var = as = call var.Encrypt() call var.Encrypt() call var.Encrypt() call var.Encrypt() call var.Encrypt() decl_stmt NetMQMessage = call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() = var decl byte var private private if != || != throw new decl_stmt var = new call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() decl_stmt var = as decl_stmt byte = call var.Decrypt() call var.Decrypt() call var.Decrypt() call var.Decrypt() call var.Decrypt() var decl byte var var private private if == && ! || != || != || == && ! || != || != throw new if == decl_stmt var = new call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call var.SetFromNetMQMessage() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() < < decl_stmt byte = call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) = decl_stmt var = == : decl_stmt var = if ! call var.SequenceEqual() call var.SequenceEqual() call var.SequenceEqual() call var.SequenceEqual() call var.SequenceEqual() throw new if == = var NetMQMessage decl byte var private private call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() call SHA256.TransformFinalBlock() < < decl_stmt byte = call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) = decl_stmt var = == : decl_stmt var = new = decl_stmt NetMQMessage = call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() call var.ToNetMQMessage() = if == private private switch case case case = = = = = break case case = = = = = break case case = = = = = break default: throw new switch case = = = break case case case = = = break case case case = = = break default: throw new private private var private private decl_stmt var = new * = public public if != call System.Security.Cryptography.RandomNumberGenerator.Dispose() call System.Security.Cryptography.RandomNumberGenerator.Dispose() call System.Security.Cryptography.RandomNumberGenerator.Dispose() call System.Security.Cryptography.RandomNumberGenerator.Dispose() call System.Security.Cryptography.RandomNumberGenerator.Dispose() = if != call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) = if != call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) call System.Security.Cryptography.SHA256.Dispose(bool) = if != call IPRF.Dispose() call IPRF.Dispose() call IPRF.Dispose() call IPRF.Dispose() call IPRF.Dispose() =