NetMQ.Core.Patterns System.Collections.Generic using System.Diagnostics using System.Text using JetBrains.Annotations using NetMQ.Core.Patterns.Utils using class NetMQ.Core.Patterns.XPub super super SocketBase decl MultiTrieDelegate Pipe bool Msg MultiTrie Distribution decl Queue bool bool bool decl MultiTrie bool bool var protected override protected override != call Distribution.Attach() call Distribution.Attach() call Distribution.Attach() call Distribution.Attach() call Distribution.Attach() if call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) if > decl_stmt var = new call var.InitEmpty() call var.InitEmpty() call var.InitEmpty() call var.InitEmpty() call var.InitEmpty() call var.Copy() call var.Copy() call var.Copy() call var.Copy() call var.Copy() ref ref var var var var var int protected override protected override decl_stmt var = new decl_stmt var = decl_stmt var = while ref decl_stmt int = decl_stmt var = if ! && ! && > && == || == if call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() new < else decl_stmt var = == call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) + - : call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) + - if == && || call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() new < else call var.Close() call var.Close() call var.Close() call var.Close() call var.Close() else if ! && && > && == call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() new < = else call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() call decl Queue.Enqueue() new < = protected override protected override call NetMQ.Core.Patterns.Utils.Distribution.Activated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Activated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Activated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Activated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Activated(Pipe) var var decl byte var protected override protected override switch case = bool return case = bool return case = bool return case if && != decl_stmt byte if is string = string else if is = else throw new if == || > throw new = = return case if && != decl_stmt var = as ?? string call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Add(byte,int,int,Pipe) = return break case if && != decl_stmt var = as ?? string call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) call NetMQ.Core.Patterns.Utils.MultiTrie.Remove(byte,int,int,Pipe) = return break case call Msg.Close() call Msg.Close() call Msg.Close() call Msg.Close() call Msg.Close() if != decl_stmt var = as if == throw new decl_stmt var = new call var.CopyTo() call var.CopyTo() call var.CopyTo() call var.CopyTo() call var.CopyTo() call Msg.InitGC() call Msg.InitGC() call Msg.InitGC() call Msg.InitGC() call Msg.InitGC() else call Msg.InitEmpty() call Msg.InitEmpty() call Msg.InitEmpty() call Msg.InitEmpty() call Msg.InitEmpty() return return protected override protected override call NetMQ.Core.Patterns.Utils.MultiTrie.RemoveHelper(Pipe,byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.RemoveHelper(Pipe,byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.RemoveHelper(Pipe,byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.RemoveHelper(Pipe,byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.RemoveHelper(Pipe,byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.Distribution.Terminated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Terminated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Terminated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Terminated(Pipe) call NetMQ.Core.Patterns.Utils.Distribution.Terminated(Pipe) if == = bool protected override protected override ref ref decl_stmt bool = if ! call NetMQ.Core.Patterns.Utils.MultiTrie.Match(byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.Match(byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.Match(byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.Match(byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.MultiTrie.Match(byte,int,int,MultiTrieDelegate,object) call NetMQ.Core.Patterns.Utils.Distribution.SendToMatching(Msg) call NetMQ.Core.Patterns.Utils.Distribution.SendToMatching(Msg) call NetMQ.Core.Patterns.Utils.Distribution.SendToMatching(Msg) call NetMQ.Core.Patterns.Utils.Distribution.SendToMatching(Msg) call NetMQ.Core.Patterns.Utils.Distribution.SendToMatching(Msg) ref if ! call NetMQ.Core.Patterns.Utils.Distribution.Unmatch() call NetMQ.Core.Patterns.Utils.Distribution.Unmatch() call NetMQ.Core.Patterns.Utils.Distribution.Unmatch() call NetMQ.Core.Patterns.Utils.Distribution.Unmatch() call NetMQ.Core.Patterns.Utils.Distribution.Unmatch() if = = = return protected override protected override return call NetMQ.Core.Patterns.Utils.Distribution.HasOut() call NetMQ.Core.Patterns.Utils.Distribution.HasOut() call NetMQ.Core.Patterns.Utils.Distribution.HasOut() call NetMQ.Core.Patterns.Utils.Distribution.HasOut() call NetMQ.Core.Patterns.Utils.Distribution.HasOut() var bool protected override protected override ref ref if == return decl_stmt var = call decl Queue.Dequeue() call decl Queue.Dequeue() call decl Queue.Dequeue() call decl Queue.Dequeue() call decl Queue.Dequeue() = decl_stmt bool = if != && ! if ! && && == = if ! && && == || == = = = = return protected override protected override return !=