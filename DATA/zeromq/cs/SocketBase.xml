NetMQ.Core System using System.Collections.Generic using System.Diagnostics using System.Linq using System.Net.Sockets using AsyncIO using JetBrains.Annotations using NetMQ.Core.Patterns using NetMQ.Core.Transports.Ipc using NetMQ.Core.Transports.Pgm using NetMQ.Core.Transports.Tcp using NetMQ.Core.Utils using NetMQ.Core.Transports.Tcp.TcpListener class NetMQ.Core.SocketBase super super Own super IPollEvents decl List Socket SocketEvents SocketBase int bool Mailbox bool bool decl Dictionary long decl Dictionary int bool Poller public public if throw new private private if throw new public static public static switch case return new case return new case return new case return new case return new case return new case return new case return new case return new case return new case return new case return new default: throw new + public override public override public public private private switch case case case break case case switch case case case case break default: throw new + break default: throw new + private private = call decl List.Add() call decl List.Add() call decl List.Add() call decl List.Add() call decl List.Add() if public public if ! PollEvents public public if == return : if == try catch return - decl_stmt PollEvents = if |= if |= return int return int PollEvents public public if == return if == return if == try catch return - decl_stmt PollEvents = if |= if |= return return bool var string var var string public public decl_stmt string decl_stmt string out out switch case decl_stmt var = new decl_stmt bool = if ! throw new = return case case if == || == return break decl_stmt var = if == throw switch case decl_stmt var = new try call var.SetAddress() call var.SetAddress() call var.SetAddress() call var.SetAddress() call var.SetAddress() = = catch call var.Destroy() call var.Destroy() call var.Destroy() call var.Destroy() call var.Destroy() throw = break case case decl_stmt var = new try call var.Init() call var.Init() call var.Init() call var.Init() call var.Init() catch call var.Destroy() call var.Destroy() call var.Destroy() call var.Destroy() call var.Destroy() throw = break case decl_stmt var = new try call var.SetAddress() call var.SetAddress() call var.SetAddress() call var.SetAddress() call var.SetAddress() = catch call var.Destroy() call var.Destroy() call var.Destroy() call var.Destroy() call var.Destroy() throw = break default: throw new string public public decl_stmt string out out if != throw new + return var decl ZObject string var decl int decl Endpoint decl int decl ZObject decl bool SessionBase bool decl int var var Pipe string decl Ctx bool var int bool public public decl_stmt string decl_stmt string out out if == decl_stmt System.ServiceModel.Endpoint = decl_stmt var = != && != + : decl_stmt var = != && != + : decl_stmt int = != && != + : decl_stmt int = != && != + : decl_stmt NetMQ.Core.ZObject = decl_stmt int = decl_stmt int = decl_stmt bool = decl_stmt NetMQ.Core.Pipe = if decl_stmt var = new call bool.InitPool() call bool.InitPool() call bool.InitPool() call bool.InitPool() call bool.InitPool() call bool.Put() call bool.Put() call bool.Put() call bool.Put() call bool.Put() call bool.SetFlags() call bool.SetFlags() call bool.SetFlags() call bool.SetFlags() call bool.SetFlags() decl_stmt bool = ref if decl_stmt var = new call bool.InitPool() call bool.InitPool() call bool.InitPool() call bool.InitPool() call bool.InitPool() call bool.Put() call bool.Put() call bool.Put() call bool.Put() call bool.Put() call bool.SetFlags() call bool.SetFlags() call bool.SetFlags() call bool.SetFlags() call bool.SetFlags() decl_stmt bool = ref = call decl Dictionary.Add() call decl Dictionary.Add() call decl Dictionary.Add() call decl Dictionary.Add() call decl Dictionary.Add() return decl_stmt var = if == throw decl_stmt var = new switch case = new call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() break case = new call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() break case case if == || == return = new call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() call var.Resolved() break decl_stmt NetMQ.Core.SessionBase = != decl_stmt bool = == || == decl_stmt NetMQ.Core.Pipe = if ! || decl_stmt NetMQ.Core.ZObject = decl_stmt int = decl_stmt int = decl_stmt bool = decl_stmt NetMQ.Core.Pipe = = call var.AttachPipe() call var.AttachPipe() call var.AttachPipe() call var.AttachPipe() call var.AttachPipe() = call var.ToString() call var.ToString() call var.ToString() call var.ToString() call var.ToString() string int private static private static out out out out decl_stmt string const const = decl_stmt int = = = + private private = new Pipe Endpoint string string public public if == throw new decl_stmt string decl_stmt string out out if == if return decl_stmt NetMQ.Core.Pipe if ! call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() out throw new call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() else decl_stmt System.ServiceModel.Endpoint if ! call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() call decl Dictionary.TryGetValue() out throw new call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() long int bool public public ref ref if ! throw new if decl_stmt bool = ref if return if == return decl_stmt int = int decl_stmt long = < : + while = ref if break if <= continue = - if <= return return bool long bool int public public ref ref if ! throw new decl_stmt bool = ref if ++ == = if ref return if == = = ref if ! return ref return decl_stmt int = int decl_stmt long = < : + decl_stmt bool = != while : = ref if = break = if > = - if <= return ref return public public = public public return public public return internal internal = = call NetMQ.Core.Utils.Poller.AddHandle(Socket,IPollEvents) call NetMQ.Core.Utils.Poller.AddHandle(Socket,IPollEvents) call NetMQ.Core.Utils.Poller.AddHandle(Socket,IPollEvents) call NetMQ.Core.Utils.Poller.AddHandle(Socket,IPollEvents) call NetMQ.Core.Utils.Poller.AddHandle(Socket,IPollEvents) call NetMQ.Core.Utils.Poller.SetPollIn(Socket) call NetMQ.Core.Utils.Poller.SetPollIn(Socket) call NetMQ.Core.Utils.Poller.SetPollIn(Socket) call NetMQ.Core.Utils.Poller.SetPollIn(Socket) call NetMQ.Core.Utils.Poller.SetPollIn(Socket) bool Command long private private decl_stmt bool decl_stmt System.Data.Query.InternalTrees.Command if != = call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() out else decl_stmt long = if != && if >= && - <= return = = call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() out while call Command.Destination() call Command.Destination() call Command.Destination() call Command.Destination() call Command.Destination() call Command.Destination() call Command.Destination() call Command.Destination() call Command.Destination() = call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() call Mailbox.TryRecv() out protected override protected override = protected override protected override protected override protected override for = != ++ protected override protected override = protected virtual protected virtual return protected virtual protected virtual return protected virtual protected virtual ref ref throw new protected virtual protected virtual return protected virtual protected virtual ref ref throw new protected virtual protected virtual throw new protected virtual protected virtual throw new protected virtual protected virtual throw new public virtual public virtual try catch finally public virtual public virtual throw new public virtual public virtual throw new private private if call Poller.RemoveHandle() call Poller.RemoveHandle() call Poller.RemoveHandle() call Poller.RemoveHandle() call Poller.RemoveHandle() public public public public public public if else var public public decl_stmt var = call decl Dictionary.Where() call decl Dictionary.Where() call decl Dictionary.Where() call decl Dictionary.Where() call decl Dictionary.Where() == foreach in call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl Dictionary.Remove() call decl List.Remove() call decl List.Remove() call decl List.Remove() call decl List.Remove() call decl List.Remove() if private private ref ref ! || = int string string public public if == return decl_stmt string decl_stmt string out out if != throw new = = decl_stmt int const const = try call NetMQ.Core.SocketBase.SetSocketOption(ZmqSocketOption,object) call NetMQ.Core.SocketBase.SetSocketOption(ZmqSocketOption,object) call NetMQ.Core.SocketBase.SetSocketOption(ZmqSocketOption,object) call NetMQ.Core.SocketBase.SetSocketOption(ZmqSocketOption,object) call NetMQ.Core.SocketBase.SetSocketOption(ZmqSocketOption,object) catch throw try call NetMQ.Core.SocketBase.Bind(string) call NetMQ.Core.SocketBase.Bind(string) call NetMQ.Core.SocketBase.Bind(string) call NetMQ.Core.SocketBase.Bind(string) call NetMQ.Core.SocketBase.Bind(string) catch throw public public if & == return new public public if & == return new public public if & == return new public public if & == return new public public if & == return new public public if & == return new public public if & == return new public public if & == return new public public if & == return new public public if & == return new private private if == return private private if != call NetMQ.Core.SocketBase.Close() call NetMQ.Core.SocketBase.Close() call NetMQ.Core.SocketBase.Close() call NetMQ.Core.SocketBase.Close() call NetMQ.Core.SocketBase.Close() = = public override public override return + + + public public switch case return case return case return case return case return case return case return case return case return default: return