NetMQ.Core System using System.Collections.Generic using System.Diagnostics using System.Net.Sockets using JetBrains.Annotations using NetMQ.Core.Patterns using NetMQ.Core.Transports using NetMQ.Core.Transports.Ipc using NetMQ.Core.Transports.Pgm using NetMQ.Core.Transports.Tcp using class NetMQ.Core.SessionBase super super Own super IProactorEvents super IMsgSink super IMsgSource bool IEngine bool IOObject decl HashSet IOThread SocketBase bool bool bool bool Pipe int Address public static public static switch case return new case return new case return new case return new case return new case return new case return new case return new case return new case return new case return new case return new default: throw new + public override public override == if call NetMQ.Core.IOObject.CancelTimer(int) call NetMQ.Core.IOObject.CancelTimer(int) call NetMQ.Core.IOObject.CancelTimer(int) call NetMQ.Core.IOObject.CancelTimer(int) call NetMQ.Core.IOObject.CancelTimer(int) = public public ! == != = call NetMQ.Core.Pipe.SetEventSink(IPipeEvents) call NetMQ.Core.Pipe.SetEventSink(IPipeEvents) call NetMQ.Core.Pipe.SetEventSink(IPipeEvents) call NetMQ.Core.Pipe.SetEventSink(IPipeEvents) call NetMQ.Core.Pipe.SetEventSink(IPipeEvents) public virtual public virtual ref ref if ! = = return if == || ! call NetMQ.Core.Pipe.Read(Msg) call NetMQ.Core.Pipe.Read(Msg) call NetMQ.Core.Pipe.Read(Msg) call NetMQ.Core.Pipe.Read(Msg) call NetMQ.Core.Pipe.Read(Msg) ref return = return public virtual public virtual ref ref if ! = if ! return if != && call NetMQ.Core.Pipe.Write(Msg) call NetMQ.Core.Pipe.Write(Msg) call NetMQ.Core.Pipe.Write(Msg) call NetMQ.Core.Pipe.Write(Msg) call NetMQ.Core.Pipe.Write(Msg) ref return return protected virtual protected virtual if = = else = = public public var private private if != call NetMQ.Core.Pipe.Rollback() call NetMQ.Core.Pipe.Rollback() call NetMQ.Core.Pipe.Rollback() call NetMQ.Core.Pipe.Rollback() call NetMQ.Core.Pipe.Rollback() call Pipe.Flush() call Pipe.Flush() call Pipe.Flush() call Pipe.Flush() call Pipe.Flush() while decl_stmt var = new call var.InitEmpty() call var.InitEmpty() call var.InitEmpty() call var.InitEmpty() call var.InitEmpty() if ! ref ! break call var.Close() call var.Close() call var.Close() call var.Close() call var.Close() public public == || call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() if == = else call decl HashSet.Remove() call decl HashSet.Remove() call decl HashSet.Remove() call decl HashSet.Remove() call decl HashSet.Remove() if ! && if != call IEngine.Terminate() call IEngine.Terminate() call IEngine.Terminate() call IEngine.Terminate() call IEngine.Terminate() = if && == && == public public if != call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() return if != call NetMQ.Core.Transports.IEngine.ActivateOut() call NetMQ.Core.Transports.IEngine.ActivateOut() call NetMQ.Core.Transports.IEngine.ActivateOut() call NetMQ.Core.Transports.IEngine.ActivateOut() call NetMQ.Core.Transports.IEngine.ActivateOut() else call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() public public if != call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() call decl HashSet.Contains() return public public throw new protected override protected override call NetMQ.Core.IOObject.SetHandler(IProactorEvents) call NetMQ.Core.IOObject.SetHandler(IProactorEvents) call NetMQ.Core.IOObject.SetHandler(IProactorEvents) call NetMQ.Core.IOObject.SetHandler(IProactorEvents) call NetMQ.Core.IOObject.SetHandler(IProactorEvents) if decl bool decl int decl ZObject decl Pipe decl int protected override protected override != if == && ! decl_stmt NetMQ.Core.ZObject = decl_stmt int = decl_stmt int = decl_stmt bool = decl_stmt NetMQ.Core.Pipe = == = == = call NetMQ.Core.Transports.IEngine.Plug(IOThread,SessionBase) call NetMQ.Core.Transports.IEngine.Plug(IOThread,SessionBase) call NetMQ.Core.Transports.IEngine.Plug(IOThread,SessionBase) call NetMQ.Core.Transports.IEngine.Plug(IOThread,SessionBase) call NetMQ.Core.Transports.IEngine.Plug(IOThread,SessionBase) public public = protected override protected override ! if == return = if > ! call NetMQ.Core.IOObject.AddTimer(long,int) call NetMQ.Core.IOObject.AddTimer(long,int) call NetMQ.Core.IOObject.AddTimer(long,int) call NetMQ.Core.IOObject.AddTimer(long,int) call NetMQ.Core.IOObject.AddTimer(long,int) = call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) != call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() call NetMQ.Core.Pipe.CheckRead() private private = public public == = != call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) private private if ! return if != && && != && != call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call NetMQ.Core.Pipe.Terminate(bool) call decl HashSet.Add() call decl HashSet.Add() call decl HashSet.Add() call decl HashSet.Add() call decl HashSet.Add() = if != - if != && == || == call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() call NetMQ.Core.Pipe.Hiccup() var IOThread private private decl_stmt NetMQ.Core.IOThread = != switch case new return case new return case case decl_stmt var = new call var.Init() call var.Init() call var.Init() call var.Init() call var.Init() return public override public override return + + + public virtual public virtual throw new public virtual public virtual throw new